<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Potential objects &mdash; quippy  documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="quippy  documentation" href="index.html" />
    <link rel="up" title="Quippy library reference" href="quippy.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">quippy  documentation</a> &raquo;</li>
          <li><a href="quippy.html" accesskey="U">Quippy library reference</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/hybrid.png" alt="Logo"/>
            </a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/potential.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-quippy.potential">
<span id="potential-objects"></span><h1>Potential objects<a class="headerlink" href="#module-quippy.potential" title="Permalink to this headline">¶</a></h1>
<p>This module encapsulates all the interatomic potentials implemented in QUIP</p>
<p>A Potential object represents an interatomic potential, a
tight binding model or an interface to an external code used to
perform calculations. It is initialised from an <cite>args_str</cite>
describing the type of potential, and an XML formatted string
<cite>param_str</cite> giving the parameters.</p>
<p>Types of Potential:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="74%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><cite>args_str</cite> prefix</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">IP</span></tt></td>
<td>Interatomic Potential</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">TB</span></tt></td>
<td>Tight Binding Model</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">FilePot</span></tt></td>
<td>File potential, used to communicate with external program</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">CallbackPot</span></tt></td>
<td>Callback potential, computation done by Python function</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">Sum</span></tt></td>
<td>Sum of two other potentials</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">ForceMixing</span></tt></td>
<td>Combination of forces from two other potentials</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Types of interatomic potential available:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><cite>args_str</cite> prefix</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">IP</span> <span class="pre">BOP</span></tt></td>
<td>Bond order potential for metals</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">IP</span> <span class="pre">BornMayer</span></tt></td>
<td>Born-Mayer potential for oxides
(e.g. BKS potential for silica)</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">IP</span> <span class="pre">Brenner</span></tt></td>
<td>Brenner (1990) potential for carbon</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">IP</span> <span class="pre">Brenner_2002</span></tt></td>
<td>Brenner (2002) reactive potential for carbon</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">IP</span> <span class="pre">Brenner_Screened</span></tt></td>
<td>Interface to Pastewka et al. screened Brenner reactive
potential for carbon</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">IP</span> <span class="pre">Coulomb</span></tt></td>
<td>Coulomb interaction: support direct summation,
Ewald and damped shifted force Coulomb potential</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">IP</span> <span class="pre">Einstein</span></tt></td>
<td>Einstein crystal potential</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">IP</span> <span class="pre">EAM_ErcolAd</span></tt></td>
<td>Embedded atom potential of Ercolessi and Adams</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">IP</span> <span class="pre">FB</span></tt></td>
<td>Flikkema and Bromley potential</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">IP</span> <span class="pre">FS</span></tt></td>
<td>Finnis-Sinclair potential for metals</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">IP</span> <span class="pre">FX</span></tt></td>
<td>Wrapper around ttm3f water potential of
Fanourgakis-Xantheas</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">IP</span> <span class="pre">GAP</span></tt></td>
<td>Gaussian approximation potential</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">IP</span> <span class="pre">Glue</span></tt></td>
<td>Generic implementation of <tt class="docutils literal"><span class="pre">glue</span></tt> potential</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">IP</span> <span class="pre">HFdimer</span></tt></td>
<td>Simple interatomic potential for an HF dimer, from
MP2 calculations</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">IP</span> <span class="pre">KIM</span></tt></td>
<td>Interface to KIM, the Knowledgebase of Interatomic
potential Models (www.openkim.org)</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">IP</span> <span class="pre">LJ</span></tt></td>
<td>Lennard-Jones potential</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">IP</span> <span class="pre">Morse</span></tt></td>
<td>Morse potential</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">IP</span> <span class="pre">PartridgeSchwenke</span></tt></td>
<td>Partridge-Schwenke model for a water monomer</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">IP</span> <span class="pre">SW</span></tt></td>
<td>Stillinger-Weber potential for silicon</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">IP</span> <span class="pre">SW_VP</span></tt></td>
<td>Combined Stillinger-Weber and Vashista potential
for Si and SiO<sub>2</sub>.</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">IP</span> <span class="pre">Si_MEAM</span></tt></td>
<td>Silicon modified embedded attom potential</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">IP</span> <span class="pre">Sutton_Chen</span></tt></td>
<td>Sutton-Chen potential</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">IP</span> <span class="pre">TS</span></tt></td>
<td>Tangney-Scandolo polarisable potential for oxides</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">IP</span> <span class="pre">Tersoff</span></tt></td>
<td>Tersoff potential for silicon</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">IP</span> <span class="pre">WaterDimer_Gillan</span></tt></td>
<td>2-body potential for water dimer</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Types of tight binding potential available:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><cite>args_str</cite> prefix</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">TB</span> <span class="pre">Bowler</span></tt></td>
<td>Bowler tight binding model</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">TB</span> <span class="pre">DFTB</span></tt></td>
<td>Density functional tight binding</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">TB</span> <span class="pre">GSP</span></tt></td>
<td>Goodwin-Skinner-Pettifor tight binding model</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">TB</span> <span class="pre">NRL_TB</span></tt></td>
<td>Naval Research Laboratory tight binding model</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Examples of the XML parameters for each of these potential can be
found in the <a class="reference external" href="http://src.tcm.phy.cam.ac.uk/viewvc/jrk33/repo/tags/QUIP_release/QUIP_Core/parameters/">QUIP_Core/parameters</a>
directory of the QUIP svn repository.</p>
<p>Module contents for <a class="reference internal" href="#module-quippy.potential" title="quippy.potential: Evaluate interatomic potentials"><tt class="xref py py-mod docutils literal"><span class="pre">quippy.potential</span></tt></a>:</p>
<p class="rubric">Classes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#quippy.potential.Potential" title="quippy.potential.Potential"><tt class="xref py py-obj docutils literal"><span class="pre">Potential</span></tt></a>(init_args[,&nbsp;pot1,&nbsp;pot2,&nbsp;param_str,&nbsp;...)</td>
<td>Provides interface to all energy/force/virial calculating schemes, including actual calculations, as well as abstract hybrid schemes such as LOTF, Force Mixing, ONIOM, and the local energy scheme.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.potential.Minim" title="quippy.potential.Minim"><tt class="xref py py-obj docutils literal"><span class="pre">Minim</span></tt></a>(atoms[,&nbsp;restart,&nbsp;relax_positions,&nbsp;...])</td>
<td>Minimise forces and/or virial tensor components wrt atomic positions and/or cell.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.potential.ForceMixingPotential" title="quippy.potential.ForceMixingPotential"><tt class="xref py py-obj docutils literal"><span class="pre">ForceMixingPotential</span></tt></a>(pot1,&nbsp;pot2[,&nbsp;...])</td>
<td>Subclass of <a class="reference internal" href="#quippy.potential.Potential" title="quippy.potential.Potential"><tt class="xref py py-class docutils literal"><span class="pre">Potential</span></tt></a> for mixing forces from two Potentials</td>
</tr>
</tbody>
</table>
<p class="rubric">Functions</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">constrain_virial_post</span></tt>(at,virial)</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">energy_func</span></tt>(x,[am_data])</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">gradient_func</span></tt>(x,[am_data])</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">pack_pos_dg</span></tt>(x2d,dg2d,lat_factor,n2)</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">unpack_pos_dg</span></tt>(xx,at_n,at_pos,dg,lat_factor)</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">print_hook</span></tt>(x,dx,e,[do_print,am_data])</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">max_rij_change</span></tt>(last_connect_x,x,r_cut,lat_factor)</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.potential.force_test" title="quippy.potential.force_test"><tt class="xref py py-obj docutils literal"><span class="pre">force_test</span></tt></a>(at,&nbsp;p[,&nbsp;dx])</td>
<td>Compare analyric and numeric forces for the Potential <cite>p</cite> with Atoms <cite>at</cite></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="quippy.potential.Potential">
<em class="property">class </em><tt class="descclassname">quippy.potential.</tt><tt class="descname">Potential</tt><big>(</big><em>init_args</em><span class="optional">[</span>, <em>pot1</em>, <em>pot2</em>, <em>param_str</em>, <em>param_filename</em>, <em>bulk_scale</em>, <em>mpi_obj</em>, <em>callback</em>, <em>calculator</em>, <em>cutoff_skin</em>, <em>atoms</em><span class="optional">]</span><big>)</big><a class="reference internal" href="_modules/quippy/potential.html#Potential"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.potential.Potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">quippy._potential.Potential</span></tt></p>
<p>Provides interface to all energy/force/virial calculating schemes,
including actual calculations, as well as abstract hybrid schemes
such as LOTF, Force Mixing, ONIOM, and the local energy scheme.</p>
<p>Typically a Potential is constructed from an initialisation
args_str and an XML parameter file, e.g. in Fortran:</p>
<div class="highlight-python"><div class="highlight"><pre>type(InOutput) :: xml_file
type(Potential) :: pot
...
call initialise(xml_file, &#39;SW.xml&#39;, INPUT)
call initialise(pot, &#39;IP SW&#39;, param_file=xml_file)
</pre></div>
</div>
<p>Or, equivaently in Python:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">pot</span> <span class="o">=</span> <span class="n">Potential</span><span class="p">(</span><span class="s">&#39;IP SW&#39;</span><span class="p">,</span> <span class="n">param_filename</span><span class="o">=</span><span class="s">&#39;SW.xml&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>creates a Stillinger-Weber potential using the parameters from
the file <tt class="docutils literal"><span class="pre">SW.xml</span></tt>. The XML parameters can also be given directly
as a string, via the <cite>param_str</cite> argument.</p>
<p>The main workhorse is the <a class="reference internal" href="#quippy.potential.Potential.calc" title="quippy.potential.Potential.calc"><tt class="xref py py-meth docutils literal"><span class="pre">calc()</span></tt></a> routine, which is used
internally to perform all calculations, e.g. to calculate forces:</p>
<div class="highlight-python"><div class="highlight"><pre>type(Atoms) :: at
real(dp) :: force(3,8)
...
call diamond(at, 5.44, 14)
call randomise(at%pos, 0.01)
call set_cutoff(at, cutoff(pot))
call calc_connect(at)
call calc(pot, at, force=force)
</pre></div>
</div>
<p>Note how the <tt class="docutils literal"><span class="pre">Atoms.cutoff</span></tt> attribute is set to the cutoff of
this Potential, and then the neighbour lists are built with the
<a class="reference internal" href="atoms.html#quippy.atoms.Atoms.calc_connect" title="quippy.atoms.Atoms.calc_connect"><tt class="xref py py-meth docutils literal"><span class="pre">calc_connect()</span></tt></a> routine.</p>
<p>A Potential can be used to optimise the geometry of an
<a class="reference internal" href="atoms.html#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> structure, using the <a class="reference internal" href="#quippy.potential.Potential.minim" title="quippy.potential.Potential.minim"><tt class="xref py py-meth docutils literal"><span class="pre">minim()</span></tt></a> routine,
(or, in Python, via  the <a class="reference internal" href="#quippy.potential.Minim" title="quippy.potential.Minim"><tt class="xref py py-class docutils literal"><span class="pre">Minim</span></tt></a> wrapper class).</p>
<p class="rubric">args_str options</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="8%" />
<col width="11%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Type</th>
<th class="head">Default</th>
<th class="head">Comments</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>minimise_bulk</td>
<td>bool</td>
<td>False</td>
<td>If true, minimise bulk_scale structure
before measuring eqm. volume and bulk
modulus for rescaling</td>
</tr>
<tr class="row-odd"><td>target_B</td>
<td>float</td>
<td>0.0</td>
<td>Target bulk modulus used if
do_rescale_E=T. Unit is GPa.</td>
</tr>
<tr class="row-even"><td>target_vol</td>
<td>float</td>
<td>0.0</td>
<td>Target volume per cell used if
do_rescale_r=T Unit is A^3.</td>
</tr>
</tbody>
</table>
<p>Wrapper around Fortran interface <tt class="docutils literal"><span class="pre">__init__</span></tt> containing multiple routines:</p>
<blockquote>
<div><dl class="function">
<dt id="quippy.potential.Potential.initialise">
<tt class="descname">initialise</tt><big>(</big><span class="optional">[</span><em>args_str</em>, <em>pot1</em>, <em>pot2</em>, <em>param_str</em>, <em>bulk_scale</em>, <em>mpi_obj</em>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.potential.Potential.initialise" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>args_str</strong> (<em>input string(len=-1), optional</em>) &#8211; Valid arguments are <tt class="docutils literal"><span class="pre">Sum</span></tt>, <tt class="docutils literal"><span class="pre">ForceMixing</span></tt>, <tt class="docutils literal"><span class="pre">EVB</span></tt>, <tt class="docutils literal"><span class="pre">Local_E_Mix</span></tt> and <tt class="docutils literal"><span class="pre">ONIOM</span></tt>, and any type of simple_potential</li>
<li><strong>pot1</strong> (<a class="reference internal" href="#quippy.potential.Potential" title="quippy.potential.Potential"><tt class="xref py py-class docutils literal"><span class="pre">Potential</span></tt></a> object, optional) &#8211; Optional first Potential upon which this Potential is based</li>
<li><strong>pot2</strong> (<a class="reference internal" href="#quippy.potential.Potential" title="quippy.potential.Potential"><tt class="xref py py-class docutils literal"><span class="pre">Potential</span></tt></a> object, optional) &#8211; Optional second potential</li>
<li><strong>param_str</strong> (<em>input string(len=-1), optional</em>) &#8211; contents of xml parameter file for potential initializers, if needed</li>
<li><strong>bulk_scale</strong> (<a class="reference internal" href="atoms.html#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object, optional) &#8211; optional bulk structure for calculating space and E rescaling</li>
<li><strong>mpi_obj</strong> (<a class="reference internal" href="mpi_context.html#quippy.mpi_context.MPI_context" title="quippy.mpi_context.MPI_context"><tt class="xref py py-class docutils literal"><span class="pre">MPI_context</span></tt></a> object, optional) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">potential_initialise</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/QUIP_Core/Potential.f95">QUIP_Core/Potential.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">initialise</tt><big>(</big><em>args_str</em>, <em>io_obj</em><span class="optional">[</span>, <em>bulk_scale</em>, <em>mpi_obj</em>, <em>error</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>args_str</strong> (<em>input string(len=-1)</em>) &#8211; Valid arguments are <tt class="docutils literal"><span class="pre">Sum</span></tt>, <tt class="docutils literal"><span class="pre">ForceMixing</span></tt>, <tt class="docutils literal"><span class="pre">EVB</span></tt>, <tt class="docutils literal"><span class="pre">Local_E_Mix</span></tt> and <tt class="docutils literal"><span class="pre">ONIOM</span></tt>, and any type of simple_potential</li>
<li><strong>io_obj</strong> (<a class="reference internal" href="system.html#quippy.system.InOutput" title="quippy.system.InOutput"><tt class="xref py py-class docutils literal"><span class="pre">InOutput</span></tt></a> object) &#8211; name of xml parameter inoutput for potential initializers</li>
<li><strong>bulk_scale</strong> (<a class="reference internal" href="atoms.html#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object, optional) &#8211; optional bulk structure for calculating space and E rescaling</li>
<li><strong>mpi_obj</strong> (<a class="reference internal" href="mpi_context.html#quippy.mpi_context.MPI_context" title="quippy.mpi_context.MPI_context"><tt class="xref py py-class docutils literal"><span class="pre">MPI_context</span></tt></a> object, optional) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">potential_initialise_inoutput</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/QUIP_Core/Potential.f95">QUIP_Core/Potential.f95</a>.</p>
</dd></dl>

</div></blockquote>
<p>The <a class="reference internal" href="#quippy.potential.Potential" title="quippy.potential.Potential"><tt class="xref py py-class docutils literal"><span class="pre">Potential</span></tt></a> class also implements the ASE
<a class="reference external" href="https://wiki.fysik.dtu.dk/ase/ase/calculators/calculators.html#ase.calculators.interface.Calculator" title="(in ASE v3.9.0.4154)"><tt class="xref py py-class docutils literal"><span class="pre">ase.calculators.interface.Calculator</span></tt></a> interface via the
the <a class="reference internal" href="#quippy.potential.Potential.get_forces" title="quippy.potential.Potential.get_forces"><tt class="xref py py-meth docutils literal"><span class="pre">get_forces()</span></tt></a>, <a class="reference internal" href="#quippy.potential.Potential.get_stress" title="quippy.potential.Potential.get_stress"><tt class="xref py py-meth docutils literal"><span class="pre">get_stress()</span></tt></a>, <a class="reference internal" href="#quippy.potential.Potential.get_stresses" title="quippy.potential.Potential.get_stresses"><tt class="xref py py-meth docutils literal"><span class="pre">get_stresses()</span></tt></a>,
<a class="reference internal" href="#quippy.potential.Potential.get_potential_energy" title="quippy.potential.Potential.get_potential_energy"><tt class="xref py py-meth docutils literal"><span class="pre">get_potential_energy()</span></tt></a>, <a class="reference internal" href="#quippy.potential.Potential.get_potential_energies" title="quippy.potential.Potential.get_potential_energies"><tt class="xref py py-meth docutils literal"><span class="pre">get_potential_energies()</span></tt></a>
methods. This simplifies calculation since there is no need
to set the cutoff or to call <a class="reference internal" href="atoms.html#quippy.atoms.Atoms.calc_connect" title="quippy.atoms.Atoms.calc_connect"><tt class="xref py py-meth docutils literal"><span class="pre">calc_connect()</span></tt></a>,
as this is done internally. The example above reduces to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">atoms</span> <span class="o">=</span> <span class="n">diamond</span><span class="p">(</span><span class="mf">5.44</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span>
<span class="n">atoms</span><span class="o">.</span><span class="n">rattle</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
<span class="n">atoms</span><span class="o">.</span><span class="n">set_calculator</span><span class="p">(</span><span class="n">pot</span><span class="p">)</span>
<span class="n">forces</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">get_forces</span><span class="p">()</span>
<span class="k">print</span> <span class="n">forces</span>
</pre></div>
</div>
<p>Note that the ASE force array is the transpose of the QUIP force
array, so has shape (len(atoms), 3) rather than (3, len(atoms)).</p>
<p>The optional arguments <cite>pot1</cite>, <cite>pot2</cite> and <cite>bulk_scale</cite> are
used by <tt class="docutils literal"><span class="pre">Sum</span></tt> and <tt class="docutils literal"><span class="pre">ForceMixing</span></tt> potentials (see also
wrapper class <a class="reference internal" href="#quippy.potential.ForceMixingPotential" title="quippy.potential.ForceMixingPotential"><tt class="xref py py-class docutils literal"><span class="pre">ForceMixingPotential</span></tt></a>)</p>
<p>An <a class="reference internal" href="mpi_context.html#quippy.mpi_context.MPI_context" title="quippy.mpi_context.MPI_context"><tt class="xref py py-class docutils literal"><span class="pre">quippy.mpi_context.MPI_context</span></tt></a> object can be
passed as the <cite>mpi_obj</cite> argument to restrict the
parallelisation of this potential to a subset of the</p>
<p>The <cite>callback</cite> argument is used to implement the calculation of
the <a class="reference internal" href="#quippy.potential.Potential" title="quippy.potential.Potential"><tt class="xref py py-class docutils literal"><span class="pre">Potential</span></tt></a> in a Python function: see <a class="reference internal" href="#quippy.potential.Potential.set_callback" title="quippy.potential.Potential.set_callback"><tt class="xref py py-meth docutils literal"><span class="pre">set_callback()</span></tt></a> for
an example.</p>
<p>In addition to the builtin QUIP potentials, it is possible to
use any ASE calculator as a QUIP potential by passing it as
the <cite>calculator</cite> argument to the <a class="reference internal" href="#quippy.potential.Potential" title="quippy.potential.Potential"><tt class="xref py py-class docutils literal"><span class="pre">Potential</span></tt></a> constructor, e.g.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ase.calculators.morse</span> <span class="kn">import</span> <span class="n">MorsePotential</span>
<span class="n">pot</span> <span class="o">=</span> <span class="n">Potential</span><span class="p">(</span><span class="n">calculator</span><span class="o">=</span><span class="n">MorsePotential</span><span class="p">)</span>
</pre></div>
</div>
<p><cite>cutoff_skin</cite> is used to set the <a class="reference internal" href="#quippy.potential.Potential.cutoff_skin" title="quippy.potential.Potential.cutoff_skin"><tt class="xref py py-attr docutils literal"><span class="pre">cutoff_skin</span></tt></a> attribute.</p>
<p><cite>atoms</cite> if given, is used to set the calculator associated
with <cite>atoms</cite> to the new <a class="reference internal" href="#quippy.potential.Potential" title="quippy.potential.Potential"><tt class="xref py py-class docutils literal"><span class="pre">Potential</span></tt></a> instance, by calling
:meth:&#8217;.Atoms.set_calculator`.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">QUIP potentials do not compute stress and per-atom stresses
directly, but rather the virial tensor which has units of stress
<img class="math" src="_images/math/c69691d64985442217922c8d34e835a9dea60178.png" alt="\times"/> volume, i.e. energy. If the total stress is
requested, it is computed by dividing the virial by the atomic
volume, obtained by calling <a class="reference internal" href="atoms.html#quippy.atoms.Atoms.get_volume" title="quippy.atoms.Atoms.get_volume"><tt class="xref py py-meth docutils literal"><span class="pre">Atoms.get_volume()</span></tt></a>. If per-atom
stresses are requested, a per-atom volume is needed. By default
this is taken to be the total volume divided by the number of
atoms. In some cases, e.g. for systems containing large amounts of
vacuum, this is not reasonable. The <tt class="docutils literal"><span class="pre">vol_per_atom</span></tt> calc_arg can
be used either to give a single per-atom volume, or the name of an
array in <a class="reference internal" href="atoms.html#quippy.atoms.Atoms.arrays" title="quippy.atoms.Atoms.arrays"><tt class="xref py py-attr docutils literal"><span class="pre">Atoms.arrays</span></tt></a> containing volumes for each atom.</p>
</div>
<p>Class is wrapper around Fortran type <tt class="docutils literal"><span class="pre">Potential</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/QUIP_Core/Potential.f95">QUIP_Core/Potential.f95</a>.</p>
<p class="rubric">Attributes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#quippy.potential.Potential.cutoff_skin" title="quippy.potential.Potential.cutoff_skin"><tt class="xref py py-obj docutils literal"><span class="pre">cutoff_skin</span></tt></a></td>
<td>The <cite>cutoff_skin</cite> attribute is only relevant when the ASE-style interface to the Potential is used, via the <a class="reference internal" href="#quippy.potential.Potential.get_forces" title="quippy.potential.Potential.get_forces"><tt class="xref py py-meth docutils literal"><span class="pre">get_forces()</span></tt></a>, <a class="reference internal" href="#quippy.potential.Potential.get_potential_energy" title="quippy.potential.Potential.get_potential_energy"><tt class="xref py py-meth docutils literal"><span class="pre">get_potential_energy()</span></tt></a> etc.</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#quippy.potential.Potential.bulk_modulus" title="quippy.potential.Potential.bulk_modulus"><tt class="xref py py-obj docutils literal"><span class="pre">bulk_modulus</span></tt></a>(pot,at,[minimise_bulk,eps,args_str])</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.potential.Potential.calc" title="quippy.potential.Potential.calc"><tt class="xref py py-obj docutils literal"><span class="pre">calc</span></tt></a>(...)</td>
<td>Apply this Potential to the Atoms object <tt class="docutils literal"><span class="pre">at</span></tt>, which must have connectivity information (i.e.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.potential.Potential.calc_elastic_constants" title="quippy.potential.Potential.calc_elastic_constants"><tt class="xref py py-obj docutils literal"><span class="pre">calc_elastic_constants</span></tt></a>(...)</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.potential.Potential.calc_electrostatic_potential" title="quippy.potential.Potential.calc_electrostatic_potential"><tt class="xref py py-obj docutils literal"><span class="pre">calc_electrostatic_potential</span></tt></a>(...)</td>
<td>Evaluate electrostatic potential on a grid by adding test atoms at grid points</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.potential.Potential.calculate" title="quippy.potential.Potential.calculate"><tt class="xref py py-obj docutils literal"><span class="pre">calculate</span></tt></a>(atoms[,&nbsp;quantities])</td>
<td>Perform a calculation of <cite>quantities</cite> for <cite>atoms</cite> using this Potential.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.potential.Potential.cutoff" title="quippy.potential.Potential.cutoff"><tt class="xref py py-obj docutils literal"><span class="pre">cutoff</span></tt></a>([error])</td>
<td>Return the cutoff of this <tt class="docutils literal"><span class="pre">Potential</span></tt>, in Angstrom.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.potential.Potential.filename_initialise" title="quippy.potential.Potential.filename_initialise"><tt class="xref py py-obj docutils literal"><span class="pre">filename_initialise</span></tt></a>(...)</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.potential.Potential.get" title="quippy.potential.Potential.get"><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt></a>(param[,&nbsp;default])</td>
<td>Get the value of a <tt class="docutils literal"><span class="pre">calc_args</span></tt> parameter for this <a class="reference internal" href="#quippy.potential.Potential" title="quippy.potential.Potential"><tt class="xref py py-class docutils literal"><span class="pre">Potential</span></tt></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.potential.Potential.get_calc_args" title="quippy.potential.Potential.get_calc_args"><tt class="xref py py-obj docutils literal"><span class="pre">get_calc_args</span></tt></a>()</td>
<td>Get the current <tt class="docutils literal"><span class="pre">calc_args</span></tt></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.potential.Potential.get_calc_args_str" title="quippy.potential.Potential.get_calc_args_str"><tt class="xref py py-obj docutils literal"><span class="pre">get_calc_args_str</span></tt></a>()</td>
<td>Get the <tt class="docutils literal"><span class="pre">calc_args</span></tt> to be passed to <a class="reference internal" href="#quippy.potential.Potential.calc" title="quippy.potential.Potential.calc"><tt class="xref py py-meth docutils literal"><span class="pre">calc()</span></tt></a> as a string</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.potential.Potential.get_default_quantities" title="quippy.potential.Potential.get_default_quantities"><tt class="xref py py-obj docutils literal"><span class="pre">get_default_quantities</span></tt></a>()</td>
<td>Get the list of quantities to be calculated by default</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.potential.Potential.get_elastic_constants" title="quippy.potential.Potential.get_elastic_constants"><tt class="xref py py-obj docutils literal"><span class="pre">get_elastic_constants</span></tt></a>(atoms)</td>
<td>Calculate elastic constants of <cite>atoms</cite> using this Potential.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.potential.Potential.get_forces" title="quippy.potential.Potential.get_forces"><tt class="xref py py-obj docutils literal"><span class="pre">get_forces</span></tt></a>(atoms)</td>
<td>Return forces on <cite>atoms</cite> calculated with this Potential</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.potential.Potential.get_numeric_forces" title="quippy.potential.Potential.get_numeric_forces"><tt class="xref py py-obj docutils literal"><span class="pre">get_numeric_forces</span></tt></a>(atoms)</td>
<td>Return forces on <cite>atoms</cite> computed with finite differences of the energy</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.potential.Potential.get_potential_energies" title="quippy.potential.Potential.get_potential_energies"><tt class="xref py py-obj docutils literal"><span class="pre">get_potential_energies</span></tt></a>(atoms)</td>
<td>Return array of atomic energies calculated with this Potential</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.potential.Potential.get_potential_energy" title="quippy.potential.Potential.get_potential_energy"><tt class="xref py py-obj docutils literal"><span class="pre">get_potential_energy</span></tt></a>(atoms)</td>
<td>Return potential energy of <cite>atoms</cite> calculated with this Potential</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.potential.Potential.get_stress" title="quippy.potential.Potential.get_stress"><tt class="xref py py-obj docutils literal"><span class="pre">get_stress</span></tt></a>(atoms)</td>
<td>Return stress tensor for <cite>atoms</cite> computed with this Potential</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.potential.Potential.get_stresses" title="quippy.potential.Potential.get_stresses"><tt class="xref py py-obj docutils literal"><span class="pre">get_stresses</span></tt></a>(atoms)</td>
<td>Return the per-atoms virial stress tensors for <cite>atoms</cite> computed with this Potential</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.potential.Potential.get_unrelaxed_elastic_constants" title="quippy.potential.Potential.get_unrelaxed_elastic_constants"><tt class="xref py py-obj docutils literal"><span class="pre">get_unrelaxed_elastic_constants</span></tt></a>(atoms)</td>
<td>Calculate unrelaxed elastic constants of <cite>atoms</cite> using this Potential</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>(atoms)</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">is_same_fortran_object</span></tt>(other)</td>
<td>Test if <cite>self</cite> and <cite>other</cite> point to the same Fortan object.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.potential.Potential.minim" title="quippy.potential.Potential.minim"><tt class="xref py py-obj docutils literal"><span class="pre">minim</span></tt></a>(...)</td>
<td>Minimise the configuration <tt class="docutils literal"><span class="pre">at</span></tt> under the action of this Potential.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.potential.Potential.n_test_gradient" title="quippy.potential.Potential.n_test_gradient"><tt class="xref py py-obj docutils literal"><span class="pre">n_test_gradient</span></tt></a>(...)</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.potential.Potential.print_" title="quippy.potential.Potential.print_"><tt class="xref py py-obj docutils literal"><span class="pre">print_</span></tt></a>([file,error])</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.potential.Potential.set" title="quippy.potential.Potential.set"><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt></a>(**kwargs)</td>
<td>Set one or more calc_args parameters for this Potential</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.potential.Potential.set_calc_args" title="quippy.potential.Potential.set_calc_args"><tt class="xref py py-obj docutils literal"><span class="pre">set_calc_args</span></tt></a>(calc_args)</td>
<td>Set the <tt class="docutils literal"><span class="pre">calc_args</span></tt> to be used subsequent <a class="reference internal" href="#quippy.potential.Potential.calc" title="quippy.potential.Potential.calc"><tt class="xref py py-meth docutils literal"><span class="pre">calc()</span></tt></a> calls</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.potential.Potential.set_callback" title="quippy.potential.Potential.set_callback"><tt class="xref py py-obj docutils literal"><span class="pre">set_callback</span></tt></a>(callback)</td>
<td>For a <a class="reference internal" href="#quippy.potential.Potential" title="quippy.potential.Potential"><tt class="xref py py-class docutils literal"><span class="pre">Potential</span></tt></a> of type <cite>CallbackPot</cite>, this method is used to set the callback function.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.potential.Potential.set_default_quantities" title="quippy.potential.Potential.set_default_quantities"><tt class="xref py py-obj docutils literal"><span class="pre">set_default_quantities</span></tt></a>(quantities)</td>
<td>Set the list of quantities to be calculated by default</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.potential.Potential.setup_parallel" title="quippy.potential.Potential.setup_parallel"><tt class="xref py py-obj docutils literal"><span class="pre">setup_parallel</span></tt></a>(at,args_str,[error])</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">shallow_copy</span></tt>()</td>
<td>Return a shallow copy of <cite>self</cite>.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">shallow_copy_from</span></tt>(other)</td>
<td>Transform <cite>self</cite> into a shallow copy of <cite>other</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.potential.Potential.test_gradient" title="quippy.potential.Potential.test_gradient"><tt class="xref py py-obj docutils literal"><span class="pre">test_gradient</span></tt></a>(...)</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.potential.Potential.test_local_virial" title="quippy.potential.Potential.test_local_virial"><tt class="xref py py-obj docutils literal"><span class="pre">test_local_virial</span></tt></a>(at,[args_str])</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.potential.Potential.update" title="quippy.potential.Potential.update"><tt class="xref py py-obj docutils literal"><span class="pre">update</span></tt></a>(atoms)</td>
<td>Set the <a class="reference internal" href="atoms.html#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object associated with this <a class="reference internal" href="#quippy.potential.Potential" title="quippy.potential.Potential"><tt class="xref py py-class docutils literal"><span class="pre">Potential</span></tt></a> to <cite>atoms</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.potential.Potential.wipe" title="quippy.potential.Potential.wipe"><tt class="xref py py-obj docutils literal"><span class="pre">wipe</span></tt></a>()</td>
<td>Mark all quantities as needing to be recalculated</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="quippy.potential.Potential.bulk_modulus">
<tt class="descname">bulk_modulus</tt><big>(</big><em>pot</em>, <em>at</em><span class="optional">[</span>, <em>minimise_bulk</em>, <em>eps</em>, <em>args_str</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.potential.Potential.bulk_modulus" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>pot</strong> : <a class="reference internal" href="#quippy.potential.Potential" title="quippy.potential.Potential"><tt class="xref py py-class docutils literal"><span class="pre">Potential</span></tt></a> object</p>
<p><strong>at</strong> : <a class="reference internal" href="atoms.html#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object</p>
<p><strong>b</strong> :  float</p>
<p><strong>v0</strong> :  float</p>
<p><strong>minimise_bulk</strong> :  input int, optional</p>
<p><strong>eps</strong> :  input float, optional</p>
<p class="last"><strong>args_str</strong> :  input string(len=-1), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">bulk_modulus</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/QUIP_Core/Potential.f95">QUIP_Core/Potential.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.Potential.calc">
<tt class="descname">calc</tt><big>(</big><em>at</em><span class="optional">[</span>, <em>energy</em>, <em>force</em>, <em>virial</em>, <em>local_energy</em>, <em>local_virial</em>, <em>args_str</em>, <em>error</em><span class="optional">]</span><big>)</big><a class="reference internal" href="_modules/quippy/potential.html#Potential.calc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.potential.Potential.calc" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply this Potential to the Atoms object
<tt class="docutils literal"><span class="pre">at</span></tt>, which must have connectivity information
(i.e. <tt class="docutils literal"><span class="pre">Atoms.calc_connect</span></tt> should have been called). The
optional arguments determine what should be calculated and how
it will be returned. Each physical quantity has a
corresponding optional argument, which can either be an <tt class="docutils literal"><span class="pre">True</span></tt>
to store the result inside the Atoms object (i.e. in
Atoms.params`` or in <a href="#id1"><span class="problematic" id="id2">``</span></a>Atoms.properties&#8217; with the
default name, a string to specify a different property or
parameter name, or an array of the the correct shape to
receive the quantity in question, as set out in the table
below.</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="19%" />
<col width="23%" />
<col width="36%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Array argument</th>
<th class="head">Quantity</th>
<th class="head">Shape</th>
<th class="head">Default storage location</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">energy</span></tt></td>
<td>Energy</td>
<td><tt class="docutils literal"><span class="pre">()</span></tt></td>
<td><tt class="docutils literal"><span class="pre">energy</span></tt> param</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">local_energy</span></tt></td>
<td>Local energy</td>
<td><tt class="docutils literal"><span class="pre">(at.n,)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">local_energy</span></tt> property</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">force</span></tt></td>
<td>Force</td>
<td><tt class="docutils literal"><span class="pre">(3,at.n)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">force</span></tt> property</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">virial</span></tt></td>
<td>Virial tensor</td>
<td><tt class="docutils literal"><span class="pre">(3,3)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">virial</span></tt> param</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">local_virial</span></tt></td>
<td>Local virial</td>
<td><tt class="docutils literal"><span class="pre">(3,3,at.n)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">local_virial</span></tt> property</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The <tt class="docutils literal"><span class="pre">args_str</span></tt> argument is an optional string  containing
additional arguments which depend on the particular Potential
being used.</p>
<p>Not all Potentials support all of these quantities: an error
will be raised if you ask for something that is not supported.</p>
<p class="rubric">args_str options</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="8%" />
<col width="11%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Type</th>
<th class="head">Default</th>
<th class="head">Comments</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>E_scale</td>
<td>float</td>
<td>0.0</td>
<td>Energy rescale factor. Overrides
E_scale init arg</td>
</tr>
<tr class="row-odd"><td>energy</td>
<td>str</td>
<td>None</td>
<td>If present, calculate energy and put it
in field with this string as name</td>
</tr>
<tr class="row-even"><td>force</td>
<td>str</td>
<td>None</td>
<td>If present, calculate force and put it
in field with this string as name</td>
</tr>
<tr class="row-odd"><td>local_energy</td>
<td>str</td>
<td>None</td>
<td>If present, calculate local energy and
put it in field with this string as
name</td>
</tr>
<tr class="row-even"><td>local_virial</td>
<td>str</td>
<td>None</td>
<td>If present, calculate local virial and
put it in field with this string as
name</td>
</tr>
<tr class="row-odd"><td>r_scale</td>
<td>float</td>
<td>0.0</td>
<td>Distance rescale factor. Overrides
r_scale init arg</td>
</tr>
<tr class="row-even"><td>virial</td>
<td>str</td>
<td>None</td>
<td>If present, calculate virial and put it
in field with this string as name</td>
</tr>
</tbody>
</table>
<p>In Python, this method is overloaded to set the final args_str to
<a class="reference internal" href="#quippy.potential.Potential.get_calc_args_str" title="quippy.potential.Potential.get_calc_args_str"><tt class="xref py py-meth docutils literal"><span class="pre">get_calc_args_str()</span></tt></a>, followed by any keyword arguments,
followed by an explicit <cite>args_str</cite> argument if present. This ordering
ensures arguments explicitly passed to <a class="reference internal" href="#quippy.potential.Potential.calc" title="quippy.potential.Potential.calc"><tt class="xref py py-meth docutils literal"><span class="pre">calc()</span></tt></a> will override any
default arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>at</strong> : <a class="reference internal" href="atoms.html#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object</p>
<p><strong>energy</strong> :  in/output rank-0 array(float,&#8217;d&#8217;), optional</p>
<p><strong>force</strong> :  in/output rank-2 array(&#8216;d&#8217;) with bounds (qp_n0,qp_n1), optional</p>
<p><strong>virial</strong> :  in/output rank-2 array(&#8216;d&#8217;) with bounds (3,3), optional</p>
<p><strong>local_energy</strong> :  in/output rank-1 array(&#8216;d&#8217;) with bounds (qp_n2), optional</p>
<p><strong>local_virial</strong> :  in/output rank-2 array(&#8216;d&#8217;) with bounds (qp_n3,qp_n4), optional</p>
<p><strong>args_str</strong> :  input string(len=-1), optional</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">calc</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/QUIP_Core/Potential.f95">QUIP_Core/Potential.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.Potential.calc_elastic_constants">
<tt class="descname">calc_elastic_constants</tt><big>(</big><em>at</em><span class="optional">[</span>, <em>fd</em>, <em>args_str</em>, <em>c</em>, <em>c0</em>, <em>relax_initial</em>, <em>return_relaxed</em>, <em>relax_tol</em>, <em>relax_method</em>, <em>linmin_method</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.potential.Potential.calc_elastic_constants" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>at</strong> : <a class="reference internal" href="atoms.html#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object</p>
<blockquote>
<div><p>Atoms object for which to compute <img class="math" src="_images/math/949e305594f67ec0c0af08516116e44b0055a318.png" alt="C_{ij}"/></p>
</div></blockquote>
<p><strong>fd</strong> :  input float, optional</p>
<blockquote>
<div><p>Finite strain to apply. Default <img class="math" src="_images/math/10b37c629b673215d5fbcfbd2ab92d849045a8bf.png" alt="10^{-2}"/>.</p>
</div></blockquote>
<p><strong>args_str</strong> :  input string(len=-1), optional</p>
<blockquote>
<div><p>Optional args_str to pass to <tt class="docutils literal"><span class="pre">minim</span></tt></p>
</div></blockquote>
<p><strong>c</strong> :  in/output rank-2 array(&#8216;d&#8217;) with bounds (6,6), optional</p>
<blockquote>
<div><p>Elastic constants (with relaxation)</p>
</div></blockquote>
<p><strong>c0</strong> :  in/output rank-2 array(&#8216;d&#8217;) with bounds (6,6), optional</p>
<blockquote>
<div><p>Elastic constants (without relaxation)</p>
</div></blockquote>
<p><strong>relax_initial</strong> :  input int, optional</p>
<blockquote>
<div><p>Should the initial cell be relaxed?</p>
</div></blockquote>
<p><strong>return_relaxed</strong> :  input int, optional</p>
<blockquote>
<div><p>If true, overwrite <tt class="docutils literal"><span class="pre">at</span></tt> with relaxed positions and lattice (default false)</p>
</div></blockquote>
<p><strong>relax_tol</strong> :  input float, optional</p>
<blockquote>
<div><p>Relaxation df:math:<cite>^2</cite> tolerance. Default 1e-8</p>
</div></blockquote>
<p><strong>relax_method</strong> :  input string(len=-1), optional</p>
<blockquote>
<div><p>method to pass for minim</p>
</div></blockquote>
<p><strong>linmin_method</strong> :  input string(len=-1), optional</p>
<blockquote class="last">
<div><p>method to pass for minim</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">pot_calc_elastic_constants</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/QUIP_Utils/elasticity.f95">QUIP_Utils/elasticity.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.Potential.calc_electrostatic_potential">
<tt class="descname">calc_electrostatic_potential</tt><big>(</big><em>at</em>, <em>cluster</em>, <em>mark_name</em>, <em>ngrid</em>, <em>origin</em>, <em>extent</em>, <em>real_grid</em>, <em>pot</em>, <em>args_str</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.potential.Potential.calc_electrostatic_potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate electrostatic potential on a grid by adding test atoms at grid points</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>at</strong> : <a class="reference internal" href="atoms.html#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object</p>
<p><strong>cluster</strong> : <a class="reference internal" href="atoms.html#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object</p>
<p><strong>mark_name</strong> :  input string(len=-1)</p>
<p><strong>ngrid</strong> :  input rank-1 array(&#8216;i&#8217;) with bounds (3)</p>
<p><strong>origin</strong> :  input rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
<p><strong>extent</strong> :  input rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
<p><strong>real_grid</strong> :  in/output rank-2 array(&#8216;d&#8217;) with bounds (qp_n0,qp_n1)</p>
<p><strong>pot</strong> :  in/output rank-3 array(&#8216;d&#8217;) with bounds (qp_n2,qp_n3,qp_n4)</p>
<p><strong>args_str</strong> :  input string(len=-1)</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">calc_electrostatic_potential</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/QUIP_Core/ElectrostaticEmbed.f95">QUIP_Core/ElectrostaticEmbed.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.Potential.calculate">
<tt class="descname">calculate</tt><big>(</big><em>atoms</em>, <em>quantities=None</em><big>)</big><a class="reference internal" href="_modules/quippy/potential.html#Potential.calculate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.potential.Potential.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a calculation of <cite>quantities</cite> for <cite>atoms</cite> using this Potential.</p>
<p>Automatically determines if a new calculation is required or if previous
results are still appliciable (i.e. if the atoms haven&#8217;t moved since last call)
Called internally by <a class="reference internal" href="#quippy.potential.Potential.get_potential_energy" title="quippy.potential.Potential.get_potential_energy"><tt class="xref py py-meth docutils literal"><span class="pre">get_potential_energy()</span></tt></a>, <a class="reference internal" href="#quippy.potential.Potential.get_forces" title="quippy.potential.Potential.get_forces"><tt class="xref py py-meth docutils literal"><span class="pre">get_forces()</span></tt></a>, etc.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.Potential.cutoff">
<tt class="descname">cutoff</tt><big>(</big><span class="optional">[</span><em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.potential.Potential.cutoff" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cutoff of this <tt class="docutils literal"><span class="pre">Potential</span></tt>, in Angstrom. This is the
minimum neighbour connectivity cutoff that should be used: if
you``re doing MD you``ll want to use a slightly larger cutoff so
that new neighbours don&#8217;t drift in to range between connectivity
updates</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>ret_potential_cutoff</strong> :  float</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">cutoff</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/QUIP_Core/Potential.f95">QUIP_Core/Potential.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.Potential.filename_initialise">
<tt class="descname">filename_initialise</tt><big>(</big><em>args_str</em>, <em>param_filename</em><span class="optional">[</span>, <em>bulk_scale</em>, <em>mpi_obj</em>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.potential.Potential.filename_initialise" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>args_str</strong> :  input string(len=-1)</p>
<blockquote>
<div><p>Valid arguments are <tt class="docutils literal"><span class="pre">Sum</span></tt>, <tt class="docutils literal"><span class="pre">ForceMixing</span></tt>, <tt class="docutils literal"><span class="pre">EVB</span></tt>, <tt class="docutils literal"><span class="pre">Local_E_Mix</span></tt> and <tt class="docutils literal"><span class="pre">ONIOM</span></tt>, and any type of simple_potential</p>
</div></blockquote>
<p><strong>param_filename</strong> :  input string(len=-1)</p>
<blockquote>
<div><p>name of xml parameter file for potential initializers</p>
</div></blockquote>
<p><strong>bulk_scale</strong> : <a class="reference internal" href="atoms.html#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object, optional</p>
<blockquote>
<div><p>optional bulk structure for calculating space and E rescaling</p>
</div></blockquote>
<p><strong>mpi_obj</strong> : <a class="reference internal" href="mpi_context.html#quippy.mpi_context.MPI_context" title="quippy.mpi_context.MPI_context"><tt class="xref py py-class docutils literal"><span class="pre">MPI_context</span></tt></a> object, optional</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">potential_filename_initialise</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/QUIP_Core/Potential.f95">QUIP_Core/Potential.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.Potential.get">
<tt class="descname">get</tt><big>(</big><em>param</em>, <em>default=None</em><big>)</big><a class="reference internal" href="_modules/quippy/potential.html#Potential.get"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.potential.Potential.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the value of a <tt class="docutils literal"><span class="pre">calc_args</span></tt> parameter for this <a class="reference internal" href="#quippy.potential.Potential" title="quippy.potential.Potential"><tt class="xref py py-class docutils literal"><span class="pre">Potential</span></tt></a></p>
<p>Returns <tt class="docutils literal"><span class="pre">None</span></tt> if <cite>param</cite> is not in the current <tt class="docutils literal"><span class="pre">calc_args</span></tt> dictionary.</p>
<p>All calc_args are passed to <a class="reference internal" href="#quippy.potential.Potential.calc" title="quippy.potential.Potential.calc"><tt class="xref py py-meth docutils literal"><span class="pre">calc()</span></tt></a> whenever energies,
forces or stresses need to be re-computed.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.Potential.get_calc_args">
<tt class="descname">get_calc_args</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/quippy/potential.html#Potential.get_calc_args"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.potential.Potential.get_calc_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current <tt class="docutils literal"><span class="pre">calc_args</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.Potential.get_calc_args_str">
<tt class="descname">get_calc_args_str</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/quippy/potential.html#Potential.get_calc_args_str"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.potential.Potential.get_calc_args_str" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the <tt class="docutils literal"><span class="pre">calc_args</span></tt> to be passed to <a class="reference internal" href="#quippy.potential.Potential.calc" title="quippy.potential.Potential.calc"><tt class="xref py py-meth docutils literal"><span class="pre">calc()</span></tt></a> as a string</p>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.Potential.get_default_quantities">
<tt class="descname">get_default_quantities</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/quippy/potential.html#Potential.get_default_quantities"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.potential.Potential.get_default_quantities" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the list of quantities to be calculated by default</p>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.Potential.get_elastic_constants">
<tt class="descname">get_elastic_constants</tt><big>(</big><em>atoms</em><big>)</big><a class="reference internal" href="_modules/quippy/potential.html#Potential.get_elastic_constants"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.potential.Potential.get_elastic_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate elastic constants of <cite>atoms</cite> using this Potential.</p>
<p>Returns  6x6 matrix <img class="math" src="_images/math/949e305594f67ec0c0af08516116e44b0055a318.png" alt="C_{ij}"/> of elastic constants.</p>
<p>The elastic contants are calculated as finite difference
derivatives of the virial stress tensor using positive and
negative strains of magnitude the <cite>cij_dx</cite> entry in
<tt class="docutils literal"><span class="pre">calc_args</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.Potential.get_forces">
<tt class="descname">get_forces</tt><big>(</big><em>atoms</em><big>)</big><a class="reference internal" href="_modules/quippy/potential.html#Potential.get_forces"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.potential.Potential.get_forces" title="Permalink to this definition">¶</a></dt>
<dd><p>Return forces on <cite>atoms</cite> calculated with this Potential</p>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.Potential.get_numeric_forces">
<tt class="descname">get_numeric_forces</tt><big>(</big><em>atoms</em><big>)</big><a class="reference internal" href="_modules/quippy/potential.html#Potential.get_numeric_forces"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.potential.Potential.get_numeric_forces" title="Permalink to this definition">¶</a></dt>
<dd><p>Return forces on <cite>atoms</cite> computed with finite differences of the energy</p>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.Potential.get_potential_energies">
<tt class="descname">get_potential_energies</tt><big>(</big><em>atoms</em><big>)</big><a class="reference internal" href="_modules/quippy/potential.html#Potential.get_potential_energies"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.potential.Potential.get_potential_energies" title="Permalink to this definition">¶</a></dt>
<dd><p>Return array of atomic energies calculated with this Potential</p>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.Potential.get_potential_energy">
<tt class="descname">get_potential_energy</tt><big>(</big><em>atoms</em><big>)</big><a class="reference internal" href="_modules/quippy/potential.html#Potential.get_potential_energy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.potential.Potential.get_potential_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return potential energy of <cite>atoms</cite> calculated with this Potential</p>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.Potential.get_stress">
<tt class="descname">get_stress</tt><big>(</big><em>atoms</em><big>)</big><a class="reference internal" href="_modules/quippy/potential.html#Potential.get_stress"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.potential.Potential.get_stress" title="Permalink to this definition">¶</a></dt>
<dd><p>Return stress tensor for <cite>atoms</cite> computed with this Potential</p>
<dl class="docutils">
<dt>Result is a 6-element array in Voigt notation:</dt>
<dd>[sigma_xx, sigma_yy, sigma_zz, sigma_yz, sigma_xz, sigma_xy]</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.Potential.get_stresses">
<tt class="descname">get_stresses</tt><big>(</big><em>atoms</em><big>)</big><a class="reference internal" href="_modules/quippy/potential.html#Potential.get_stresses"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.potential.Potential.get_stresses" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the per-atoms virial stress tensors for <cite>atoms</cite> computed with this Potential</p>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.Potential.get_unrelaxed_elastic_constants">
<tt class="descname">get_unrelaxed_elastic_constants</tt><big>(</big><em>atoms</em><big>)</big><a class="reference internal" href="_modules/quippy/potential.html#Potential.get_unrelaxed_elastic_constants"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.potential.Potential.get_unrelaxed_elastic_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate unrelaxed elastic constants of <cite>atoms</cite> using this Potential</p>
<p>Returns 6x6 matrix <img class="math" src="_images/math/9b4cf60a93dc0a6a47824138339d8d03b69ec3f7.png" alt="C^0_{ij}"/> of unrelaxed elastic constants.</p>
<p>The elastic contants are calculated as finite difference
derivatives of the virial stress tensor using positive and
negative strains of magnitude the <cite>cij_dx</cite> entry in
<tt class="xref py py-attr docutils literal"><span class="pre">calc_args</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.Potential.minim">
<tt class="descname">minim</tt><big>(</big><em>at</em>, <em>method</em>, <em>convergence_tol</em>, <em>max_steps</em><span class="optional">[</span>, <em>linminroutine</em>, <em>do_print</em>, <em>print_inoutput</em>, <em>print_cinoutput</em>, <em>do_pos</em>, <em>do_lat</em>, <em>args_str</em>, <em>eps_guess</em>, <em>fire_minim_dt0</em>, <em>fire_minim_dt_max</em>, <em>external_pressure</em>, <em>use_precond</em>, <em>hook_print_interval</em>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.potential.Potential.minim" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimise the configuration <tt class="docutils literal"><span class="pre">at</span></tt> under the action of this
Potential.  Returns number of minimisation steps taken. If
an error occurs or convergence is not reached within <tt class="docutils literal"><span class="pre">max_steps</span></tt>
steps, <tt class="docutils literal"><span class="pre">status</span></tt> will be set to 1 on exit.</p>
<p>Example usage (in Python, Fortran code is similar. See
<a class="reference internal" href="tutorial.html#geomopt"><em>Structural optimisation</em></a> in the quippy tutorial for full
explanation):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">at0</span> <span class="o">=</span> <span class="n">diamond</span><span class="p">(</span><span class="mf">5.44</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span>
<span class="n">at0</span><span class="o">.</span><span class="n">calc_connect</span><span class="p">()</span>
<span class="n">pot</span> <span class="o">=</span> <span class="n">Potential</span><span class="p">(</span><span class="s">&#39;IP SW&#39;</span><span class="p">,</span> <span class="n">param_str</span><span class="o">=</span><span class="s">&#39;&#39;&#39;&lt;SW_params n_types=&quot;1&quot;</span>
<span class="s">        &lt;comment Stillinger and Weber, Phys. Rev. B  31 p 5262 (1984)&lt;/comment</span>
<span class="s">        &lt;per_type_data type=&quot;1&quot; atomic_num=&quot;14&quot; /</span>

<span class="s">        &lt;per_pair_data atnum_i=&quot;14&quot; atnum_j=&quot;14&quot; AA=&quot;7.049556277&quot; BB=&quot;0.6022245584&quot;</span>
<span class="s">          p=&quot;4&quot; q=&quot;0&quot; a=&quot;1.80&quot; sigma=&quot;2.0951&quot; eps=&quot;2.1675&quot; /</span>

<span class="s">        &lt;per_triplet_data atnum_c=&quot;14&quot; atnum_j=&quot;14&quot; atnum_k=&quot;14&quot;</span>
<span class="s">          lambda=&quot;21.0&quot; gamma=&quot;1.20&quot; eps=&quot;2.1675&quot; /</span>
<span class="s">       &lt;/SW_params&#39;&#39;&#39;</span><span class="p">)</span>
<span class="n">pot</span><span class="o">.</span><span class="n">minim</span><span class="p">(</span><span class="n">at0</span><span class="p">,</span> <span class="s">&#39;cg&#39;</span><span class="p">,</span> <span class="mf">1e-7</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">do_pos</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">do_lat</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>at</strong> : <a class="reference internal" href="atoms.html#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object</p>
<blockquote>
<div><p>starting configuration</p>
</div></blockquote>
<p><strong>method</strong> :  input string(len=-1)</p>
<blockquote>
<div><p>passed to minim()</p>
</div></blockquote>
<p><strong>convergence_tol</strong> :  input float</p>
<blockquote>
<div><p>Minimisation is treated as converged once <img class="math" src="_images/math/6683c9bb745c189f0e0cf01a43ff06c047188e2e.png" alt="|\mathbf{\nabla}f|^2 &lt;"/>
<tt class="docutils literal"><span class="pre">convergence_tol</span></tt>.</p>
</div></blockquote>
<p><strong>max_steps</strong> :  input int</p>
<blockquote>
<div><p>Maximum number of steps</p>
</div></blockquote>
<p><strong>linminroutine</strong> :  input string(len=-1), optional</p>
<blockquote>
<div><p>Name of the line minisation routine to use, passed to base minim()</p>
</div></blockquote>
<p><strong>do_print</strong> :  input int, optional</p>
<blockquote>
<div><p>if true, print configurations using minim&#8217;s hook()</p>
</div></blockquote>
<p><strong>print_inoutput</strong> : <a class="reference internal" href="system.html#quippy.system.InOutput" title="quippy.system.InOutput"><tt class="xref py py-class docutils literal"><span class="pre">InOutput</span></tt></a> object, optional</p>
<blockquote>
<div><p>inoutput object to print configs to, needed if do_print is true</p>
</div></blockquote>
<p><strong>print_cinoutput</strong> : <tt class="xref py py-class docutils literal"><span class="pre">CInOutput</span></tt> object, optional</p>
<blockquote>
<div><p>cinoutput object to print configs to, needed if do_print is true</p>
</div></blockquote>
<p><strong>do_pos</strong> :  input int, optional</p>
<blockquote>
<div><p>do relaxation w.r.t. positions and/or lattice (if neither is included, do both)</p>
</div></blockquote>
<p><strong>do_lat</strong> :  input int, optional</p>
<blockquote>
<div><p>do relaxation w.r.t. positions and/or lattice (if neither is included, do both)</p>
</div></blockquote>
<p><strong>args_str</strong> :  input string(len=-1), optional</p>
<blockquote>
<div><p>arguments to pass to calc()</p>
</div></blockquote>
<p><strong>eps_guess</strong> :  input float, optional</p>
<blockquote>
<div><p>eps_guess argument to pass to minim</p>
</div></blockquote>
<p><strong>fire_minim_dt0</strong> :  input float, optional</p>
<blockquote>
<div><p>if using fire minim, initial value for time step</p>
</div></blockquote>
<p><strong>fire_minim_dt_max</strong> :  input float, optional</p>
<blockquote>
<div><p>if using fire minim, max value for time step</p>
</div></blockquote>
<p><strong>external_pressure</strong> :  input rank-2 array(&#8216;d&#8217;) with bounds (3,3), optional</p>
<p><strong>use_precond</strong> :  input int, optional</p>
<p><strong>hook_print_interval</strong> :  input int, optional</p>
<blockquote>
<div><p>how often to print xyz from hook function</p>
</div></blockquote>
<p><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
<blockquote>
<div><p>set to 1 if an error occurred during minimisation</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_potential_minim</strong> :  int</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">minim</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/QUIP_Core/Potential.f95">QUIP_Core/Potential.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.Potential.n_test_gradient">
<tt class="descname">n_test_gradient</tt><big>(</big><em>pot</em>, <em>at</em><span class="optional">[</span>, <em>do_pos</em>, <em>do_lat</em>, <em>args_str</em>, <em>dir_field</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.potential.Potential.n_test_gradient" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>pot</strong> : <a class="reference internal" href="#quippy.potential.Potential" title="quippy.potential.Potential"><tt class="xref py py-class docutils literal"><span class="pre">Potential</span></tt></a> object</p>
<p><strong>at</strong> : <a class="reference internal" href="atoms.html#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object</p>
<p><strong>do_pos</strong> :  input int, optional</p>
<p><strong>do_lat</strong> :  input int, optional</p>
<p><strong>args_str</strong> :  input string(len=-1), optional</p>
<p class="last"><strong>dir_field</strong> :  input string(len=-1), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">n_test_gradient</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/QUIP_Core/Potential.f95">QUIP_Core/Potential.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.Potential.print_">
<tt class="descname">print_</tt><big>(</big><span class="optional">[</span><em>file</em>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.potential.Potential.print_" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>file</strong> : <a class="reference internal" href="system.html#quippy.system.InOutput" title="quippy.system.InOutput"><tt class="xref py py-class docutils literal"><span class="pre">InOutput</span></tt></a> object, optional</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">print_</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/QUIP_Core/Potential.f95">QUIP_Core/Potential.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.Potential.set">
<tt class="descname">set</tt><big>(</big><em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/quippy/potential.html#Potential.set"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.potential.Potential.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set one or more calc_args parameters for this Potential</p>
<p>All calc_args are passed to <a class="reference internal" href="#quippy.potential.Potential.calc" title="quippy.potential.Potential.calc"><tt class="xref py py-meth docutils literal"><span class="pre">calc()</span></tt></a> whenever energies,
forces or stresses need to be computed.</p>
<p>After updating the calc_args, <a class="reference internal" href="#quippy.potential.Potential.set" title="quippy.potential.Potential.set"><tt class="xref py py-meth docutils literal"><span class="pre">set()</span></tt></a> calls <a class="reference internal" href="#quippy.potential.Potential.wipe" title="quippy.potential.Potential.wipe"><tt class="xref py py-meth docutils literal"><span class="pre">wipe()</span></tt></a>
to mark all quantities as needing to be recaculated.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.Potential.set_calc_args">
<tt class="descname">set_calc_args</tt><big>(</big><em>calc_args</em><big>)</big><a class="reference internal" href="_modules/quippy/potential.html#Potential.set_calc_args"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.potential.Potential.set_calc_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the <tt class="docutils literal"><span class="pre">calc_args</span></tt> to be used subsequent <a class="reference internal" href="#quippy.potential.Potential.calc" title="quippy.potential.Potential.calc"><tt class="xref py py-meth docutils literal"><span class="pre">calc()</span></tt></a> calls</p>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.Potential.set_callback">
<tt class="descname">set_callback</tt><big>(</big><em>callback</em><big>)</big><a class="reference internal" href="_modules/quippy/potential.html#Potential.set_callback"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.potential.Potential.set_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>For a <a class="reference internal" href="#quippy.potential.Potential" title="quippy.potential.Potential"><tt class="xref py py-class docutils literal"><span class="pre">Potential</span></tt></a> of type <cite>CallbackPot</cite>, this method is
used to set the callback function. <cite>callback</cite> should be a Python
function (or other callable, such as a bound method or class
instance) which takes a single argument, of type
<a class="reference internal" href="atoms.html#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a>. Information about which quantities should be
computed can be obtained from the <cite>calc_energy</cite>, <cite>calc_local_e</cite>,
<cite>calc_force</cite>, and <cite>calc_virial</cite> keys in <cite>at.params</cite>. Results
should be returned either as <cite>at.params</cite> entries (for energy and
virial) or by adding new atomic properties (for forces and local
energy).</p>
<p>Here&#8217;s an example implementation of a simple callback:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">example_callback</span><span class="p">(</span><span class="n">at</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">at</span><span class="o">.</span><span class="n">calc_energy</span><span class="p">:</span>
       <span class="n">at</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s">&#39;energy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span>

    <span class="k">if</span> <span class="n">at</span><span class="o">.</span><span class="n">calc_force</span><span class="p">:</span>
       <span class="n">at</span><span class="o">.</span><span class="n">add_property</span><span class="p">(</span><span class="s">&#39;force&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">n_cols</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
       <span class="n">at</span><span class="o">.</span><span class="n">force</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="o">...</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">Potential</span><span class="p">(</span><span class="s">&#39;CallbackPot&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">set_callback</span><span class="p">(</span><span class="n">example_callback</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="n">energy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">print</span> <span class="n">at</span><span class="o">.</span><span class="n">energy</span>
<span class="o">...</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.Potential.set_default_quantities">
<tt class="descname">set_default_quantities</tt><big>(</big><em>quantities</em><big>)</big><a class="reference internal" href="_modules/quippy/potential.html#Potential.set_default_quantities"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.potential.Potential.set_default_quantities" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the list of quantities to be calculated by default</p>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.Potential.setup_parallel">
<tt class="descname">setup_parallel</tt><big>(</big><em>at</em>, <em>args_str</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.potential.Potential.setup_parallel" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>at</strong> : <a class="reference internal" href="atoms.html#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object</p>
<blockquote>
<div><p>The atoms structure to compute energy and forces</p>
</div></blockquote>
<p><strong>args_str</strong> :  input string(len=-1)</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">setup_parallel</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/QUIP_Core/Potential.f95">QUIP_Core/Potential.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.Potential.test_gradient">
<tt class="descname">test_gradient</tt><big>(</big><em>pot</em>, <em>at</em><span class="optional">[</span>, <em>do_pos</em>, <em>do_lat</em>, <em>args_str</em>, <em>dir_field</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.potential.Potential.test_gradient" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>pot</strong> : <a class="reference internal" href="#quippy.potential.Potential" title="quippy.potential.Potential"><tt class="xref py py-class docutils literal"><span class="pre">Potential</span></tt></a> object</p>
<p><strong>at</strong> : <a class="reference internal" href="atoms.html#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object</p>
<p><strong>do_pos</strong> :  input int, optional</p>
<p><strong>do_lat</strong> :  input int, optional</p>
<p><strong>args_str</strong> :  input string(len=-1), optional</p>
<p><strong>dir_field</strong> :  input string(len=-1), optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_pot_test_gradient</strong> :  int</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">test_gradient</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/QUIP_Core/Potential.f95">QUIP_Core/Potential.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.Potential.test_local_virial">
<tt class="descname">test_local_virial</tt><big>(</big><em>at</em><span class="optional">[</span>, <em>args_str</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.potential.Potential.test_local_virial" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>at</strong> : <a class="reference internal" href="atoms.html#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object</p>
<p class="last"><strong>args_str</strong> :  input string(len=-1), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">test_local_virial</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/QUIP_Core/Potential.f95">QUIP_Core/Potential.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.Potential.update">
<tt class="descname">update</tt><big>(</big><em>atoms</em><big>)</big><a class="reference internal" href="_modules/quippy/potential.html#Potential.update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.potential.Potential.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the <a class="reference internal" href="atoms.html#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object associated with this <a class="reference internal" href="#quippy.potential.Potential" title="quippy.potential.Potential"><tt class="xref py py-class docutils literal"><span class="pre">Potential</span></tt></a> to <cite>atoms</cite>.</p>
<p>Called internally by <a class="reference internal" href="#quippy.potential.Potential.get_potential_energy" title="quippy.potential.Potential.get_potential_energy"><tt class="xref py py-meth docutils literal"><span class="pre">get_potential_energy()</span></tt></a>,
<a class="reference internal" href="#quippy.potential.Potential.get_forces" title="quippy.potential.Potential.get_forces"><tt class="xref py py-meth docutils literal"><span class="pre">get_forces()</span></tt></a>, etc.  Only a weak reference to <cite>atoms</cite> is
kept, to prevent circular references.  If <cite>atoms</cite> is not a
<a class="reference internal" href="atoms.html#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">quippy.atoms.Atoms</span></tt></a> instance, then a copy is made and a
warning will be printed.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.Potential.wipe">
<tt class="descname">wipe</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/quippy/potential.html#Potential.wipe"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.potential.Potential.wipe" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark all quantities as needing to be recalculated</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.potential.Potential.cutoff_skin">
<tt class="descname">cutoff_skin</tt><a class="headerlink" href="#quippy.potential.Potential.cutoff_skin" title="Permalink to this definition">¶</a></dt>
<dd><p>The <cite>cutoff_skin</cite> attribute is only relevant when the ASE-style
interface to the Potential is used, via the <a class="reference internal" href="#quippy.potential.Potential.get_forces" title="quippy.potential.Potential.get_forces"><tt class="xref py py-meth docutils literal"><span class="pre">get_forces()</span></tt></a>,
<a class="reference internal" href="#quippy.potential.Potential.get_potential_energy" title="quippy.potential.Potential.get_potential_energy"><tt class="xref py py-meth docutils literal"><span class="pre">get_potential_energy()</span></tt></a> etc. methods. In this case the
connectivity of the <a class="reference internal" href="atoms.html#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object for which
the calculation is requested is automatically kept up to date by
using a neighbour cutoff of <a class="reference internal" href="#quippy.potential.Potential.cutoff" title="quippy.potential.Potential.cutoff"><tt class="xref py py-meth docutils literal"><span class="pre">cutoff()</span></tt></a> + <cite>cutoff_skin</cite>, and
recalculating the neighbour lists whenever the maximum displacement
since the last <tt class="xref py py-meth docutils literal"><span class="pre">Atoms.calc_connect()</span></tt> exceeds <cite>cutoff_skin</cite>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="quippy.potential.ForceMixingPotential">
<em class="property">class </em><tt class="descclassname">quippy.potential.</tt><tt class="descname">ForceMixingPotential</tt><big>(</big><em>pot1</em>, <em>pot2</em>, <em>bulk_scale=None</em>, <em>mpi_obj=None</em>, <em>callback=None</em>, <em>calculator=None</em>, <em>cutoff_skin=1.0</em>, <em>atoms=None</em>, <em>qm_list=None</em>, <em>fpointer=None</em>, <em>finalise=True</em>, <em>error=None</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/quippy/potential.html#ForceMixingPotential"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.potential.ForceMixingPotential" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#quippy.potential.Potential" title="quippy.potential.Potential"><tt class="xref py py-class docutils literal"><span class="pre">quippy.potential.Potential</span></tt></a></p>
<p>Subclass of <a class="reference internal" href="#quippy.potential.Potential" title="quippy.potential.Potential"><tt class="xref py py-class docutils literal"><span class="pre">Potential</span></tt></a> for mixing forces from two Potentials</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#quippy.potential.ForceMixingPotential.get_qm_atoms" title="quippy.potential.ForceMixingPotential.get_qm_atoms"><tt class="xref py py-obj docutils literal"><span class="pre">get_qm_atoms</span></tt></a>()</td>
<td>Return the current list of QM atom indices as a list</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.potential.ForceMixingPotential.set_qm_atoms" title="quippy.potential.ForceMixingPotential.set_qm_atoms"><tt class="xref py py-obj docutils literal"><span class="pre">set_qm_atoms</span></tt></a>(qm_list)</td>
<td>Set the QM atoms, given as a list of atom indices</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="quippy.potential.ForceMixingPotential.get_qm_atoms">
<tt class="descname">get_qm_atoms</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/quippy/potential.html#ForceMixingPotential.get_qm_atoms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.potential.ForceMixingPotential.get_qm_atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current list of QM atom indices as a list</p>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.ForceMixingPotential.set_qm_atoms">
<tt class="descname">set_qm_atoms</tt><big>(</big><em>qm_list</em><big>)</big><a class="reference internal" href="_modules/quippy/potential.html#ForceMixingPotential.set_qm_atoms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.potential.ForceMixingPotential.set_qm_atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the QM atoms, given as a list of atom indices</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="quippy.potential.Minim">
<em class="property">class </em><tt class="descclassname">quippy.potential.</tt><tt class="descname">Minim</tt><big>(</big><em>atoms</em>, <em>restart=None</em>, <em>relax_positions=True</em>, <em>relax_cell=True</em>, <em>logfile='-'</em>, <em>trajectory=None</em>, <em>method='cg'</em>, <em>linminroutine=None</em>, <em>eps_guess=None</em>, <em>fire_dt0=None</em>, <em>fire_dt_max=None</em>, <em>external_pressure=None</em>, <em>use_precond=None</em>, <em>cutoff_skin=1.0</em><big>)</big><a class="reference internal" href="_modules/quippy/potential.html#Minim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.potential.Minim" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimise forces and/or virial tensor components wrt atomic
positions and/or cell.</p>
<p>This class is a wrapper around the
<a class="reference internal" href="#quippy.potential.Potential.minim" title="quippy.potential.Potential.minim"><tt class="xref py py-meth docutils literal"><span class="pre">quippy.potential.Potential.minim()</span></tt></a> routine, compatible with
the ASE <a class="reference external" href="https://wiki.fysik.dtu.dk/ase/ase/optimize.html">optimizer inferface</a>.</p>
<p><cite>method</cite> should be one of <tt class="docutils literal"><span class="pre">&quot;sd&quot;</span></tt>, (steepest descent), <tt class="docutils literal"><span class="pre">&quot;cg&quot;</span></tt>
(conjugate gradients, the default), <tt class="docutils literal"><span class="pre">&quot;cg_n&quot;</span></tt> (Noam Bernstein&#8217;s conjugate gradients
implementation), <tt class="docutils literal"><span class="pre">&quot;pcg&quot;</span></tt>, (preconditioned conjugate gradients),
<tt class="docutils literal"><span class="pre">&quot;lbfgs&quot;</span></tt> (L-BFGS), or <tt class="docutils literal"><span class="pre">&quot;fire&quot;</span></tt> (FIRE).</p>
<p>Example usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">quippy.structures</span> <span class="kn">import</span> <span class="n">diamond</span>
<span class="kn">from</span> <span class="nn">quippy.potential</span> <span class="kn">import</span> <span class="n">Potential</span><span class="p">,</span> <span class="n">Minim</span>

<span class="n">orig_atoms</span> <span class="o">=</span> <span class="n">diamond</span><span class="p">(</span><span class="mf">5.44</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span>
<span class="n">atoms</span> <span class="o">=</span> <span class="n">orig_atoms</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">atoms</span><span class="o">.</span><span class="n">rattle</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>  <span class="c"># randomise the atomic positions a little</span>

<span class="n">potential</span> <span class="o">=</span> <span class="n">Potential</span><span class="p">(</span><span class="s">&#39;IP SW&#39;</span><span class="p">)</span>
<span class="n">atoms</span><span class="o">.</span><span class="n">set_calculator</span><span class="p">(</span><span class="n">potential</span><span class="p">)</span>

<span class="n">minimiser</span> <span class="o">=</span> <span class="n">Minim</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">relax_positions</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">relax_cell</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">minimiser</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">fmax</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>

<span class="k">print</span> <span class="n">orig_atoms</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="n">atoms</span><span class="o">.</span><span class="n">positions</span> <span class="c"># should be approx zero</span>
</pre></div>
</div>
<p>Note that if the <a class="reference internal" href="atoms.html#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object passed to the
<a class="reference internal" href="#quippy.potential.Minim" title="quippy.potential.Minim"><tt class="xref py py-class docutils literal"><span class="pre">Minim</span></tt></a> constructor is a <a class="reference internal" href="atoms.html#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">quippy.atoms.Atoms</span></tt></a>
instance, the minimisation is done in place.  Otherwise, a copy is
made, but the relaxed positions and cell vectors are copied back
at the end of the :meth`run` method.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#quippy.potential.Minim.get_number_of_steps" title="quippy.potential.Minim.get_number_of_steps"><tt class="xref py py-obj docutils literal"><span class="pre">get_number_of_steps</span></tt></a>()</td>
<td>Return number of steps taken during minimisation</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.potential.Minim.run" title="quippy.potential.Minim.run"><tt class="xref py py-obj docutils literal"><span class="pre">run</span></tt></a>([fmax,&nbsp;steps,&nbsp;convergence_tol])</td>
<td>Run the minimiser until maximum force is below <cite>fmax</cite>.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="quippy.potential.Minim.get_number_of_steps">
<tt class="descname">get_number_of_steps</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/quippy/potential.html#Minim.get_number_of_steps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.potential.Minim.get_number_of_steps" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of steps taken during minimisation</p>
</dd></dl>

<dl class="method">
<dt id="quippy.potential.Minim.run">
<tt class="descname">run</tt><big>(</big><em>fmax=0.05</em>, <em>steps=100000000</em>, <em>convergence_tol=None</em><big>)</big><a class="reference internal" href="_modules/quippy/potential.html#Minim.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.potential.Minim.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the minimiser until maximum force is below <cite>fmax</cite>.</p>
<p>Maximum number of minimisation steps is given by <cite>steps</cite>.</p>
<p>Note that QUIP minim convergence criteria is actually based on
<img class="math" src="_images/math/5e51a76738b55be86cc637842ee7b053b6edf167.png" alt="|\mathbf{f}|^2"/> rather than on the maximum force. Here
we convert using the relation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">convergence_tol</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">*</span><span class="n">fmax</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
<p>which is only approximately equivalent. To specify the converengence
tolerance exactly, pass a value for the <cite>convergence_tol</cite> argument.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="quippy.potential.force_test">
<tt class="descclassname">quippy.potential.</tt><tt class="descname">force_test</tt><big>(</big><em>at</em>, <em>p</em>, <em>dx=0.0001</em><big>)</big><a class="reference internal" href="_modules/quippy/potential.html#force_test"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.potential.force_test" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare analyric and numeric forces for the Potential <cite>p</cite> with Atoms <cite>at</cite></p>
<p>Finite difference derivates are calculated by moving each atom by <cite>dx</cite>.</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">quippy  documentation</a> &raquo;</li>
          <li><a href="quippy.html" >Quippy library reference</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2008-2015, James Kermode.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>