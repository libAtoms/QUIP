<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Atoms objects &mdash; quippy b9f75c6+ documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     'b9f75c6+',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="quippy b9f75c6+ documentation" href="index.html" />
    <link rel="up" title="Quippy library reference" href="quippy.html" />
    <link rel="prev" title="Quippy library reference" href="quippy.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="quippy.html" title="Quippy library reference"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">quippy b9f75c6+ documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="quippy.html" accesskey="U">Quippy library reference</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/hybrid.png" alt="Logo"/>
            </a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="quippy.html"
                        title="previous chapter">Quippy library reference</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/atoms.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-quippy.atoms">
<span id="atoms-objects"></span><h1>Atoms objects<a class="headerlink" href="#module-quippy.atoms" title="Permalink to this headline">¶</a></h1>
<p>This module defines the <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><code class="xref py py-class docutils literal"><span class="pre">Atoms</span></code></a>, which stores and manipulates a
collection of atoms, as well as the <a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> class which stores
topology and neighbour lists, and the <a class="reference internal" href="domaindecomposition.html#quippy.atoms.DomainDecomposition" title="quippy.atoms.DomainDecomposition"><code class="xref py py-class docutils literal"><span class="pre">DomainDecomposition</span></code></a> class.</p>
<p>Module contents for <a class="reference internal" href="#module-quippy.atoms" title="quippy.atoms: Representation of atomic configurations"><code class="xref py py-mod docutils literal"><span class="pre">quippy.atoms</span></code></a>:</p>
<p class="rubric">Classes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><code class="xref py py-obj docutils literal"><span class="pre">Connection</span></code></a>(...)</td>
<td>The Connection type stores the topology of a set of Atoms</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><code class="xref py py-obj docutils literal"><span class="pre">Atoms</span></code></a>([symbols,&nbsp;positions,&nbsp;numbers,&nbsp;tags,&nbsp;...)</td>
<td>Representation of an atomic configuration and its associated properties</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">NeighbourInfo</span></code>(j,&nbsp;distance,&nbsp;diff,&nbsp;cosines,&nbsp;shift)</td>
<td>Store information about a single neighbour of an atom</td>
</tr>
</tbody>
</table>
<p class="rubric">Functions</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.get_lattice_params" title="quippy.atoms.get_lattice_params"><code class="xref py py-obj docutils literal"><span class="pre">get_lattice_params</span></code></a>(lattice)</td>
<td>Wrapper around Fortran <code class="xref py py-func docutils literal"><span class="pre">get_lattice_params_()</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.get_lattice_params" title="quippy.atoms.get_lattice_params"><code class="xref py py-obj docutils literal"><span class="pre">get_lattice_params</span></code></a>(lattice)</td>
<td>Wrapper around Fortran <code class="xref py py-func docutils literal"><span class="pre">get_lattice_params_()</span></code></td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="84%" />
<col width="16%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="xref py py-attr docutils literal"><span class="pre">DD_WRAP_TO_DOMAIN</span></code></td>
<td>2</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-attr docutils literal"><span class="pre">NOT_NEIGHBOUR</span></code></td>
<td>0</td>
</tr>
<tr class="row-even"><td><code class="xref py py-attr docutils literal"><span class="pre">DEFAULT_NNEIGHTOL</span></code></td>
<td>1.2</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-attr docutils literal"><span class="pre">CONNECT_LATTICE_TOL</span></code></td>
<td>1e-08</td>
</tr>
<tr class="row-even"><td><code class="xref py py-attr docutils literal"><span class="pre">DD_WRAP_TO_CELL</span></code></td>
<td>1</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="quippy.atoms.Atoms">
<em class="property">class </em><code class="descclassname">quippy.atoms.</code><code class="descname">Atoms</code><span class="sig-paren">(</span><span class="optional">[</span><em>symbols</em>, <em>positions</em>, <em>numbers</em>, <em>tags</em>, <em>momenta</em>, <em>masses</em>, <em>magmoms</em>, <em>charges</em>, <em>scaled_positions</em>, <em>cell</em>, <em>pbc</em>, <em>constraint</em>, <em>calculator</em>, <em>info</em>, <em>n</em>, <em>lattice</em>, <em>properties</em>, <em>params</em>, <em>fixed_size</em>, <em>**read_args</em><span class="optional">]</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/quippy/atoms.html#Atoms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">quippy._atoms.Atoms</span></code>, <a class="reference external" href="https://wiki.fysik.dtu.dk/ase/ase/atoms.html#ase.atoms.Atoms" title="(in ASE v)"><code class="xref py py-class docutils literal"><span class="pre">ase.atoms.Atoms</span></code></a></p>
<p>Representation of an atomic configuration and its associated properties</p>
<p>An atoms object contains atomic numbers, all dynamical variables
and connectivity information for all the atoms in the simulation cell.
It is initialised like this:</p>
<div class="highlight-python"><div class="highlight"><pre>call initialise(MyAtoms,N,lattice)
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">N</span></code> is the number of atoms to allocate space for and <code class="docutils literal"><span class="pre">lattice</span></code> is a <img class="math" src="_images/math/59ca78535a2bfd005ddf503222102c74a0199b90.png" alt="3\times3"/>
matrix of lattice vectors given as column vectors, so that <code class="docutils literal"><span class="pre">lattice(:,i)</span></code> is the i-th lattice vector.</p>
<p>Atoms also contains a Connection object, which stores distance information about
the atom neghbours after <code class="docutils literal"><span class="pre">calc_connect</span></code> has been called. Rather than using a minimum
image convention, all neighbours are stored up to a radius of <code class="docutils literal"><span class="pre">cutoff</span></code>, including images</p>
<p>Initialise type(Atoms), pointer objects. Shallow copies of these will
survive even if the initial declaration goes out of scope. The object will
automatically deallocate upon calling finalise_ptr when the last shallow
copy goes out of scope</p>
<p>The <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><code class="xref py py-class docutils literal"><span class="pre">Atoms</span></code></a> class is a Pythonic wrapper over the auto-generated
<code class="xref py py-class docutils literal"><span class="pre">quippy._atoms.Atoms</span></code> class. Atoms object are usually
constructed either by reading from an input file in one of the
<a class="reference internal" href="io.html#fileformats"><span>Supported File Formats</span></a>, or by using the structure creation functions in
the <a class="reference internal" href="structures.html#module-quippy.structures" title="quippy.structures: Structure building routines"><code class="xref py py-mod docutils literal"><span class="pre">quippy.structures</span></code></a> or <a class="reference external" href="https://wiki.fysik.dtu.dk/ase/ase/lattice.html#module-ase.lattice" title="(in ASE v)"><code class="xref py py-mod docutils literal"><span class="pre">ase.lattice</span></code></a> modules.</p>
<p>For example to read from an <a class="reference internal" href="io.html#extendedxyz"><span>Extended XYZ</span></a> file, use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">quippy.atoms</span> <span class="kn">import</span> <span class="n">Atoms</span>
<span class="n">atoms</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span><span class="s">&#39;filename.xyz&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Or, to create an 8-atom bulk diamond cubic cell of silicon:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">quippy.structures</span> <span class="kn">import</span> <span class="n">diamond</span>
<span class="n">si_bulk</span> <span class="o">=</span> <span class="n">diamond</span><span class="p">(</span><span class="mf">5.44</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><code class="xref py py-class docutils literal"><span class="pre">Atoms</span></code></a> class is inherited from the
<a class="reference external" href="https://wiki.fysik.dtu.dk/ase/ase/atoms.html#ase.atoms.Atoms" title="(in ASE v)"><code class="xref py py-class docutils literal"><span class="pre">ase.atoms.Atoms</span></code></a> so has all the ASE Atoms attributes and
methods. This means that quippy and ASE Atoms objects are fully
interoperable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>n</strong> :  input int</p>
<p><strong>lattice</strong> :  input rank-2 array(&#8216;d&#8217;) with bounds (3,3)</p>
<p><strong>properties</strong> : <a class="reference internal" href="dictionary.html#quippy.dictionary.Dictionary" title="quippy.dictionary.Dictionary"><code class="xref py py-class docutils literal"><span class="pre">Dictionary</span></code></a> object, optional</p>
<p><strong>params</strong> : <a class="reference internal" href="dictionary.html#quippy.dictionary.Dictionary" title="quippy.dictionary.Dictionary"><code class="xref py py-class docutils literal"><span class="pre">Dictionary</span></code></a> object, optional</p>
<p><strong>fixed_size</strong> :  input int, optional</p>
<p><strong>nbuffer</strong> :  input int, optional</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">__init__initialise_ptr</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.
Class is wrapper around Fortran type <code class="docutils literal"><span class="pre">Atoms</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
<p class="rubric">Attributes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.arrays" title="quippy.atoms.Atoms.arrays"><code class="xref py py-obj docutils literal"><span class="pre">arrays</span></code></a></td>
<td>Provides access to ASE arrays, stored in QUIP properties dict</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.indices" title="quippy.atoms.Atoms.indices"><code class="xref py py-obj docutils literal"><span class="pre">indices</span></code></a></td>
<td>Return array of atoms indices</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.info" title="quippy.atoms.Atoms.info"><code class="xref py py-obj docutils literal"><span class="pre">info</span></code></a></td>
<td>ASE info dictionary</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.copy_from" title="quippy.atoms.Atoms.copy_from"><code class="xref py py-obj docutils literal"><span class="pre">copy_from</span></code></a>(other)</td>
<td>Replace contents of this Atoms object with data from <cite>other</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.density" title="quippy.atoms.Atoms.density"><code class="xref py py-obj docutils literal"><span class="pre">density</span></code></a>()</td>
<td>Density in units of <img class="math" src="_images/math/846ffd8410b4e884443d8b7f2df37cc417186f4c.png" alt="g/m^3"/>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.equivalent" title="quippy.atoms.Atoms.equivalent"><code class="xref py py-obj docutils literal"><span class="pre">equivalent</span></code></a>(other)</td>
<td>Test for equivalence of two Atoms objects.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_atom" title="quippy.atoms.Atoms.get_atom"><code class="xref py py-obj docutils literal"><span class="pre">get_atom</span></code></a>(i)</td>
<td>Return a dictionary containing the properties of the atom with index <cite>i</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.iteratoms" title="quippy.atoms.Atoms.iteratoms"><code class="xref py py-obj docutils literal"><span class="pre">iteratoms</span></code></a>()</td>
<td>Iterate over atoms, calling get_atom() for each one</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.md5_hash" title="quippy.atoms.Atoms.md5_hash"><code class="xref py py-obj docutils literal"><span class="pre">md5_hash</span></code></a>(ndigits)</td>
<td>Hash an atoms object with a precision of ndigits decimal digits.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.mem_estimate" title="quippy.atoms.Atoms.mem_estimate"><code class="xref py py-obj docutils literal"><span class="pre">mem_estimate</span></code></a>()</td>
<td>Estimate memory usage of this Atoms object, in bytes</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.print_atom" title="quippy.atoms.Atoms.print_atom"><code class="xref py py-obj docutils literal"><span class="pre">print_atom</span></code></a>(i)</td>
<td>Pretty-print the properties of the atom with index <cite>i</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.read_from" title="quippy.atoms.Atoms.read_from"><code class="xref py py-obj docutils literal"><span class="pre">read_from</span></code></a>(source,&nbsp;**readargs)</td>
<td>Replace contents of this Atoms object with Atoms read from <cite>source</cite></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="quippy.atoms.Atoms.add_atoms">
<code class="descname">add_atoms</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.add_atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Add one or more atoms to an Atoms object.
To add a single atom, &#8216;pos&#8217; should be an array of size 3 and &#8216;z a
single integer. To add multiple atoms either arrays of length
&#8216;n_new&#8217; should be passed, or another Atoms from which to copy data
should be given as the &#8216;from&#8217; argument.</p>
<p>Wrapper around Fortran interface <code class="docutils literal"><span class="pre">add_atoms</span></code> containing multiple routines:</p>
<blockquote>
<div><dl class="function">
<dt>
<code class="descname">add_atoms</code><span class="sig-paren">(</span><em>pos</em>, <em>z</em><span class="optional">[</span>, <em>mass</em>, <em>travel</em>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pos</strong> (<em>input rank-1 array(&#8216;d&#8217;) with bounds (3)</em>) &#8211; </li>
<li><strong>z</strong> (<em>input int</em>) &#8211; </li>
<li><strong>mass</strong> (<em>input float, optional</em>) &#8211; </li>
<li><strong>travel</strong> (<em>input rank-1 array(&#8216;i&#8217;) with bounds (3), optional</em>) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">add_atom_single</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">add_atoms</code><span class="sig-paren">(</span><em>from</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>from</strong> (<a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><code class="xref py py-class docutils literal"><span class="pre">Atoms</span></code></a> object) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_join</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">add_atoms</code><span class="sig-paren">(</span><em>pos</em>, <em>z</em><span class="optional">[</span>, <em>mass</em>, <em>velo</em>, <em>acc</em>, <em>travel</em>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pos</strong> (<em>input rank-2 array(&#8216;d&#8217;) with bounds (qp_n0,qp_n1)</em>) &#8211; </li>
<li><strong>z</strong> (<em>input rank-1 array(&#8216;i&#8217;) with bounds (qp_n2)</em>) &#8211; </li>
<li><strong>mass</strong> (<em>input rank-1 array(&#8216;d&#8217;) with bounds (qp_n3), optional</em>) &#8211; </li>
<li><strong>velo</strong> (<em>input rank-2 array(&#8216;d&#8217;) with bounds (qp_n4,qp_n5), optional</em>) &#8211; </li>
<li><strong>acc</strong> (<em>input rank-2 array(&#8216;d&#8217;) with bounds (qp_n6,qp_n7), optional</em>) &#8211; </li>
<li><strong>travel</strong> (<em>input rank-2 array(&#8216;i&#8217;) with bounds (qp_n8,qp_n9), optional</em>) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">add_atom_multiple</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.add_cut_hydrogens">
<code class="descname">add_cut_hydrogens</code><span class="sig-paren">(</span><em>qmlist</em><span class="optional">[</span>, <em>heuristics_nneighb_only</em>, <em>verbosity</em>, <em>alt_connect</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.add_cut_hydrogens" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an atoms structure and a list of quantum atoms, find X-H
bonds which have been cut and include the other atom of
the pair in the quantum list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>qmlist</strong> : <a class="reference internal" href="table.html#quippy.table.Table" title="quippy.table.Table"><code class="xref py py-class docutils literal"><span class="pre">Table</span></code></a> object</p>
<p><strong>heuristics_nneighb_only</strong> :  input int, optional</p>
<p><strong>verbosity</strong> :  input int, optional</p>
<p class="last"><strong>alt_connect</strong> : <a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> object, optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">add_cut_hydrogens</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/clusters.f95">src/libAtoms/clusters.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.add_property">
<code class="descname">add_property</code><span class="sig-paren">(</span><em>name</em>, <em>value</em>, <em>n_cols=None</em>, <em>overwrite=None</em>, <em>property_type=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.add_property"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.add_property" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new property to this Atoms object.</p>
<p><cite>name</cite> is the name of the new property and <cite>value</cite> should be
either a scalar or an array representing the value, which should
be either integer, real, logical or string.</p>
<p>If a scalar is given for <cite>value</cite> it is copied to every element
in the new property.  <cite>n_cols</cite> can be specified to create a 2D
property from a scalar initial value - the default is 1 which
creates a 1D property.</p>
<p>If an array is given for <cite>value</cite> it should either have shape
(self.n,) for a 1D property or (n_cols,self.n) for a 2D
property.  In this case <cite>n_cols</cite> is inferred from the shape of
the <cite>value</cite> and shouldn&#8217;t be passed as an argument.</p>
<p>If <cite>property_type</cite> is present, then no attempt is made to
infer the type from <cite>value</cite>. This is necessary to resolve
ambiguity between integer and logical types.</p>
<p>If property with the same type is already present then no error
occurs.If <cite>overwrite</cite> is true, the value will be overwritten with
that given in <cite>value</cite>, otherwise the old value is retained.</p>
<p>Here are some examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="mf">10.0</span><span class="o">*</span><span class="n">fidentity</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>

<span class="n">a</span><span class="o">.</span><span class="n">add_property</span><span class="p">(</span><span class="s">&#39;mark&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>                  <span class="c"># Scalar integer</span>
<span class="n">a</span><span class="o">.</span><span class="n">add_property</span><span class="p">(</span><span class="s">&#39;bool&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>              <span class="c"># Scalar logical</span>
<span class="n">a</span><span class="o">.</span><span class="n">add_property</span><span class="p">(</span><span class="s">&#39;local_energy&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>        <span class="c"># Scalar real</span>
<span class="n">a</span><span class="o">.</span><span class="n">add_property</span><span class="p">(</span><span class="s">&#39;force&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">n_cols</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>     <span class="c"># Vector real</span>
<span class="n">a</span><span class="o">.</span><span class="n">add_property</span><span class="p">(</span><span class="s">&#39;label&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>                <span class="c"># Scalar string</span>

<span class="n">a</span><span class="o">.</span><span class="n">add_property</span><span class="p">(</span><span class="s">&#39;count&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>  <span class="c"># From list</span>
<span class="n">a</span><span class="o">.</span><span class="n">add_property</span><span class="p">(</span><span class="s">&#39;norm_pos&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">norm</span><span class="p">())</span>         <span class="c"># From 1D array</span>
<span class="n">a</span><span class="o">.</span><span class="n">add_property</span><span class="p">(</span><span class="s">&#39;pos&#39;</span><span class="p">,</span> <span class="n">new_pos</span><span class="p">)</span>                   <span class="c"># Overwrite positions with array new_pos</span>
                                                 <span class="c"># which should have shape (3,10)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.add_property_from_pointer">
<code class="descname">add_property_from_pointer</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.add_property_from_pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a per-atom property to this atoms object, but point to existing space
rather than allocating new space for it (as add_property does).</p>
<p>Wrapper around Fortran interface <code class="docutils literal"><span class="pre">add_property_from_pointer</span></code> containing multiple routines:</p>
<blockquote>
<div><dl class="function">
<dt>
<code class="descname">add_property_from_pointer</code><span class="sig-paren">(</span><em>name</em>, <em>ptr</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>ptr</strong> (<em>input rank-3 array(&#8216;S&#8217;) with bounds (qp_n0,qp_n1,(1))</em>) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_add_property_p_str</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">add_property_from_pointer</code><span class="sig-paren">(</span><em>name</em>, <em>ptr</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>ptr</strong> (<em>input rank-1 array(&#8216;d&#8217;) with bounds (qp_n0)</em>) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_add_property_p_real</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">add_property_from_pointer</code><span class="sig-paren">(</span><em>name</em>, <em>ptr</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>ptr</strong> (<em>input rank-1 array(&#8216;i&#8217;) with bounds (qp_n0)</em>) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_add_property_p_int</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">add_property_from_pointer</code><span class="sig-paren">(</span><em>name</em>, <em>ptr</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>ptr</strong> (<em>input rank-2 array(&#8216;d&#8217;) with bounds (qp_n0,qp_n1)</em>) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_add_property_p_real_a</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">add_property_from_pointer</code><span class="sig-paren">(</span><em>name</em>, <em>ptr</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>ptr</strong> (<em>input rank-2 array(&#8216;i&#8217;) with bounds (qp_n0,qp_n1)</em>) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_add_property_p_int_a</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">add_property_from_pointer</code><span class="sig-paren">(</span><em>name</em>, <em>ptr</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>ptr</strong> (<em>input rank-1 array(&#8216;i&#8217;) with bounds (qp_n0)</em>) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_add_property_p_logical</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.angular_momentum">
<code class="descname">angular_momentum</code><span class="sig-paren">(</span><span class="optional">[</span><em>origin</em>, <em>indices</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.angular_momentum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the angular momentum of all the atoms in this DynamicalSystem, defined by
<img class="math" src="_images/math/ede2d8f94fbc6c451abbbe27d607904bcef7f7c0.png" alt="\mathbf{L} = \sum_{i} \mathbf{r_i} \times \mathbf{v_i}"/>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>origin</strong> :  input rank-1 array(&#8216;d&#8217;) with bounds (3), optional</p>
<p><strong>indices</strong> :  input rank-1 array(&#8216;i&#8217;) with bounds (qp_n0), optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_l</strong> :  rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_angular_momentum</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/DynamicalSystem.f95">src/libAtoms/DynamicalSystem.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>atom</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.append"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append atom to end.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.assignment">
<code class="descname">assignment</code><span class="sig-paren">(</span><em>to</em>, <em>from</em><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.assignment" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded assigment operators for Atoms objects.
Overloaded assigment operators for Connection objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>to</strong> : <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><code class="xref py py-class docutils literal"><span class="pre">Atoms</span></code></a> object</p>
<p class="last"><strong>from</strong> : <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><code class="xref py py-class docutils literal"><span class="pre">Atoms</span></code></a> object</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">assignment</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.bfs_grow_list">
<code class="descname">bfs_grow_list</code><span class="sig-paren">(</span><em>list</em>, <em>n</em><span class="optional">[</span>, <em>nneighb_only</em>, <em>min_images_only</em>, <em>alt_connect</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.bfs_grow_list" title="Permalink to this definition">¶</a></dt>
<dd><p>On exit, <code class="docutils literal"><span class="pre">list</span></code> will have been grown by <code class="docutils literal"><span class="pre">n</span></code> bond hops.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>list</strong> : <a class="reference internal" href="table.html#quippy.table.Table" title="quippy.table.Table"><code class="xref py py-class docutils literal"><span class="pre">Table</span></code></a> object</p>
<p><strong>n</strong> :  input int</p>
<p><strong>nneighb_only</strong> :  input int, optional</p>
<p><strong>min_images_only</strong> :  input int, optional</p>
<p class="last"><strong>alt_connect</strong> : <a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> object, optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">bfs_grow_list</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/clusters.f95">src/libAtoms/clusters.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.bfs_grow_single">
<code class="descname">bfs_grow_single</code><span class="sig-paren">(</span><em>atom</em>, <em>n</em><span class="optional">[</span>, <em>nneighb_only</em>, <em>min_images_only</em>, <em>alt_connect</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.bfs_grow_single" title="Permalink to this definition">¶</a></dt>
<dd><p>On exit, <code class="docutils literal"><span class="pre">list</span></code> will contain <code class="docutils literal"><span class="pre">atom</span></code> (with shift <code class="docutils literal"><span class="pre">000</span></code>)
plus the atoms within <code class="docutils literal"><span class="pre">n</span></code> bonds hops of it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>atom</strong> :  input int</p>
<p><strong>n</strong> :  input int</p>
<p><strong>nneighb_only</strong> :  input int, optional</p>
<p><strong>min_images_only</strong> :  input int, optional</p>
<p><strong>alt_connect</strong> : <a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> object, optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>list</strong> : <a class="reference internal" href="table.html#quippy.table.Table" title="quippy.table.Table"><code class="xref py py-class docutils literal"><span class="pre">Table</span></code></a> object</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">bfs_grow_single</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/clusters.f95">src/libAtoms/clusters.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.bfs_step">
<code class="descname">bfs_step</code><span class="sig-paren">(</span><em>input</em><span class="optional">[</span>, <em>nneighb_only</em>, <em>min_images_only</em>, <em>max_r</em>, <em>alt_connect</em>, <em>property</em>, <em>debugfile</em>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.bfs_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute one Breadth-First-Search move on the atomic connectivity graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>input</strong> : <a class="reference internal" href="table.html#quippy.table.Table" title="quippy.table.Table"><code class="xref py py-class docutils literal"><span class="pre">Table</span></code></a> object</p>
<blockquote>
<div><p>Table with intsize 4. First integer column is indices of atoms
already in the region, next 3 are shifts.</p>
</div></blockquote>
<p><strong>nneighb_only</strong> :  input int, optional</p>
<blockquote>
<div><p>If present and true, sets whether only neighbours
within the sum of the two respective covalent radii (multiplied by the atom&#8217;s nneightol) are included,
irrespective of the cutoff in the atoms structure
(default is true).</p>
</div></blockquote>
<p><strong>min_images_only</strong> :  input int, optional</p>
<blockquote>
<div><p>If true, there will be no repeated atomic indices in final list - only the
minimum shift image of those found will be included. Default is false.</p>
</div></blockquote>
<p><strong>max_r</strong> :  input float, optional</p>
<blockquote>
<div><p>if present, only neighbors within this range will be included</p>
</div></blockquote>
<p><strong>alt_connect</strong> : <a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> object, optional</p>
<p><strong>property</strong> :  input rank-1 array(&#8216;i&#8217;) with bounds (qp_n0), optional</p>
<p><strong>debugfile</strong> : <a class="reference internal" href="system.html#quippy.system.InOutput" title="quippy.system.InOutput"><code class="xref py py-class docutils literal"><span class="pre">InOutput</span></code></a> object, optional</p>
<p><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : <a class="reference internal" href="table.html#quippy.table.Table" title="quippy.table.Table"><code class="xref py py-class docutils literal"><span class="pre">Table</span></code></a> object</p>
<blockquote class="last">
<div><p>Table with intsize 4, containing the new atomic
indices and shifts.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">bfs_step</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/clusters.f95">src/libAtoms/clusters.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.calc_connect">
<code class="descname">calc_connect</code><span class="sig-paren">(</span><span class="optional">[</span><em>alt_connect</em>, <em>own_neighbour</em>, <em>store_is_min_image</em>, <em>skip_zero_zero_bonds</em>, <em>store_n_neighb</em>, <em>max_pos_change</em>, <em>did_rebuild</em>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.calc_connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast <img class="math" src="_images/math/4d51d3f476c76dc066b26271168bc3b67f49d2be.png" alt="O(N)"/> connectivity calculation routine. It divides the unit
cell into similarly shaped subcells, of sufficient size that
sphere of radius <code class="docutils literal"><span class="pre">cutoff</span></code> is contained in a subcell, at least in
the directions in which the unit cell is big enough. For very
small unit cells, there is only one subcell, so the routine is
equivalent to the standard <img class="math" src="_images/math/8912be2deda42f022bc42bf2ab30cb3c7c6f5d55.png" alt="O(N^2)"/> method.&gt;
If <code class="docutils literal"><span class="pre">own_neighbour</span></code> is true, atoms can be neighbours with their
own periodic images.
If <code class="docutils literal"><span class="pre">cutoff_skin</span></code> is present, effective cutoff is increased by this
amount, and full recalculation of connectivity is only done when
any atom has moved more than 0.5*cutoff_skin - otherwise
calc_dists() is called to update the stored distance tables.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>alt_connect</strong> : <a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> object, optional</p>
<p><strong>own_neighbour</strong> :  input int, optional</p>
<p><strong>store_is_min_image</strong> :  input int, optional</p>
<p><strong>skip_zero_zero_bonds</strong> :  input int, optional</p>
<p><strong>store_n_neighb</strong> :  input int, optional</p>
<p><strong>max_pos_change</strong> :  in/output rank-0 array(float,&#8217;d&#8217;), optional</p>
<p><strong>did_rebuild</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">calc_connect</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.calc_connect_hysteretic">
<code class="descname">calc_connect_hysteretic</code><span class="sig-paren">(</span><em>cutoff_factor</em>, <em>cutoff_break_factor</em><span class="optional">[</span>, <em>alt_connect</em>, <em>origin</em>, <em>extent</em>, <em>own_neighbour</em>, <em>store_is_min_image</em>, <em>store_n_neighb</em>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.calc_connect_hysteretic" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>As for <code class="docutils literal"><span class="pre">calc_connect</span></code>, but perform the connectivity update
hystertically: atoms must come within a relative distance of</div></blockquote>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">cutoff_factor</span></code> to be considered neighbours, and then will remain</dt>
<dd><p class="first">connected until them move apart further than a relative distance
of <code class="docutils literal"><span class="pre">cutoff_break_factor</span></code> (all cutoff factors are relative
to covalent radii).</p>
<p class="last">Typically <code class="docutils literal"><span class="pre">alt_connect</span></code> should be set to the
<code class="docutils literal"><span class="pre">hysteretic_connect</span></code> attribute. <code class="docutils literal"><span class="pre">origin</span></code> and <code class="docutils literal"><span class="pre">extent</span></code>
vectors can be used to restrict the hysteretic region to only
part of the entire system &#8211; the <code class="docutils literal"><span class="pre">estimate_origin_extent()</span></code>
routine in clusters.f95 can be used to guess suitable values.</p>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>cutoff_factor</strong> :  input float</p>
<p><strong>cutoff_break_factor</strong> :  input float</p>
<p><strong>alt_connect</strong> : <a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> object, optional</p>
<p><strong>origin</strong> :  input rank-1 array(&#8216;d&#8217;) with bounds (3), optional</p>
<p><strong>extent</strong> :  input rank-2 array(&#8216;d&#8217;) with bounds (3,3), optional</p>
<p><strong>own_neighbour</strong> :  input int, optional</p>
<p><strong>store_is_min_image</strong> :  input int, optional</p>
<p><strong>store_n_neighb</strong> :  input int, optional</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">calc_connect_hysteretic</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.calc_dists">
<code class="descname">calc_dists</code><span class="sig-paren">(</span><span class="optional">[</span><em>alt_connect</em>, <em>parallel</em>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.calc_dists" title="Permalink to this definition">¶</a></dt>
<dd><p>Update stored distance tables. To be called after moving atoms, in between calls to calc_connect().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>alt_connect</strong> : <a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> object, optional</p>
<p><strong>parallel</strong> :  input int, optional</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">calc_dists</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.calc_msd">
<code class="descname">calc_msd</code><span class="sig-paren">(</span><em>at</em><span class="optional">[</span>, <em>mask</em>, <em>reset_msd</em>, <em>persistent</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.calc_msd" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate mean squared displacement, with or without persistent atoms object
without persistent atoms object, global storage is used, and calling on multiple trajcetories
interspersed will not work.
usually desirable to call undo_pbc_jumps and undo_CoM_motion first</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>at</strong> : <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><code class="xref py py-class docutils literal"><span class="pre">Atoms</span></code></a> object</p>
<p><strong>mask</strong> :  input rank-1 array(&#8216;i&#8217;) with bounds (qp_n0), optional</p>
<p><strong>reset_msd</strong> :  input int, optional</p>
<p class="last"><strong>persistent</strong> :  input int, optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">calc_msd</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.calc_qw">
<code class="descname">calc_qw</code><span class="sig-paren">(</span><em>l</em><span class="optional">[</span>, <em>do_q</em>, <em>do_w</em>, <em>cutoff</em>, <em>cutoff_transition_width</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.calc_qw" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>l</strong> :  input int</p>
<p><strong>do_q</strong> :  input int, optional</p>
<p><strong>do_w</strong> :  input int, optional</p>
<p><strong>cutoff</strong> :  input float, optional</p>
<p class="last"><strong>cutoff_transition_width</strong> :  input float, optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">calc_qw</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/steinhardt_nelson_qw.f95">src/libAtoms/steinhardt_nelson_qw.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.calc_qw_grad">
<code class="descname">calc_qw_grad</code><span class="sig-paren">(</span><em>grad_ind</em>, <em>l</em><span class="optional">[</span>, <em>do_q</em>, <em>do_w</em>, <em>cutoff</em>, <em>cutoff_transition_width</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.calc_qw_grad" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>grad_ind</strong> :  input int</p>
<p><strong>l</strong> :  input int</p>
<p><strong>do_q</strong> :  input int, optional</p>
<p><strong>do_w</strong> :  input int, optional</p>
<p><strong>cutoff</strong> :  input float, optional</p>
<p class="last"><strong>cutoff_transition_width</strong> :  input float, optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">calc_qw_grad</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/steinhardt_nelson_qw.f95">src/libAtoms/steinhardt_nelson_qw.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.cell_volume">
<code class="descname">cell_volume</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.cell_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>atoms_cell_volume</p>
<p>calculate volume of unit cell
Returns the (unsigned) volume of the simulation cell of this Atoms</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>ret_atoms_cell_volume</strong> :  float</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">cell_volume</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.center">
<code class="descname">center</code><span class="sig-paren">(</span><em>vacuum=None</em>, <em>axis=(0</em>, <em>1</em>, <em>2)</em>, <em>about=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.center"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.center" title="Permalink to this definition">¶</a></dt>
<dd><p>Center atoms in unit cell.</p>
<p>Centers the atoms in the unit cell, so there is the same
amount of vacuum on all sides.</p>
<dl class="docutils">
<dt>vacuum: float (default: None)</dt>
<dd>If specified adjust the amount of vacuum when centering.
If vacuum=10.0 there will thus be 10 Angstrom of vacuum
on each side.</dd>
<dt>axis: int or sequence of ints</dt>
<dd>Axis or axes to act on.  Default: Act on all axes.</dd>
<dt>about: float or array (default: None)</dt>
<dd>If specified, center the atoms about &lt;about&gt;.
I.e., about=(0., 0., 0.) (or just &#8220;about=0.&#8221;, interpreted
identically), to center about the origin.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.centre_of_mass">
<code class="descname">centre_of_mass</code><span class="sig-paren">(</span><em>at</em><span class="optional">[</span>, <em>index_list</em>, <em>mask</em>, <em>origin</em>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.centre_of_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the centre of mass of an atoms object, using the closest images to the origin atom,
or first atom if this is not specified.  If origin is zero, use actual position, not minimum image.
If an <code class="docutils literal"><span class="pre">index_list</span></code> is present, just calculate it for that subset of atoms (then the origin atom is
the first in this list unless it is specified separately).</p>
<p>Note: Because the origin can be specified separately it need not be one of the atoms in the
calculation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>at</strong> : <code class="xref py py-class docutils literal"><span class="pre">atoms</span></code> object</p>
<p><strong>index_list</strong> :  input rank-1 array(&#8216;i&#8217;) with bounds (qp_n0), optional</p>
<p><strong>mask</strong> :  input rank-1 array(&#8216;i&#8217;) with bounds (qp_n1), optional</p>
<p><strong>origin</strong> :  input int, optional</p>
<p><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_com</strong> :  rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">centre_of_mass</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.closest_atom">
<code class="descname">closest_atom</code><span class="sig-paren">(</span><em>r</em>, <em>cell_image_na</em>, <em>cell_image_nb</em>, <em>cell_image_nc</em><span class="optional">[</span>, <em>mask</em>, <em>dist</em>, <em>diff</em>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.closest_atom" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>r</strong> :  input rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
<p><strong>cell_image_na</strong> :  input int</p>
<p><strong>cell_image_nb</strong> :  input int</p>
<p><strong>cell_image_nc</strong> :  input int</p>
<p><strong>mask</strong> :  input rank-1 array(&#8216;i&#8217;) with bounds (qp_n0), optional</p>
<p><strong>dist</strong> :  in/output rank-0 array(float,&#8217;d&#8217;), optional</p>
<p><strong>diff</strong> :  in/output rank-1 array(&#8216;d&#8217;) with bounds (3), optional</p>
<p><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_closest_atom</strong> :  int</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">closest_atom</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.coalesce_in_one_periodic_image">
<code class="descname">coalesce_in_one_periodic_image</code><span class="sig-paren">(</span><span class="optional">[</span><em>seed</em>, <em>is_periodic</em>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.coalesce_in_one_periodic_image" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>move atoms around following neighbor list bonds so that all are in the same periodic image</dt>
<dd>(that of <code class="docutils literal"><span class="pre">seed</span></code>, if present)</dd>
</dl>
<p>poorly tested, especially for situations where not all atoms are in one connected clump
probably needs a better subroutine name</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seed</strong> :  input int, optional</p>
<p><strong>is_periodic</strong> :  input rank-1 array(&#8216;i&#8217;) with bounds (3), optional</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">coalesce_in_one_periodic_image</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.complement">
<code class="descname">complement</code><span class="sig-paren">(</span><em>at</em>, <em>inlist</em><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.complement" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the complement of a list, i.e. all those atoms not included
in list. Result is in outlist on exit.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>at</strong> : <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><code class="xref py py-class docutils literal"><span class="pre">Atoms</span></code></a> object</p>
<p><strong>inlist</strong> : <a class="reference internal" href="table.html#quippy.table.Table" title="quippy.table.Table"><code class="xref py py-class docutils literal"><span class="pre">Table</span></code></a> object</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>outlist</strong> : <a class="reference internal" href="table.html#quippy.table.Table" title="quippy.table.Table"><code class="xref py py-class docutils literal"><span class="pre">Table</span></code></a> object</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">complement</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of this <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><code class="xref py py-class docutils literal"><span class="pre">Atoms</span></code></a> object</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.copy_entry">
<code class="descname">copy_entry</code><span class="sig-paren">(</span><em>src</em>, <em>dst</em><span class="optional">[</span>, <em>swap</em>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.copy_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy an atom to a different index
Move a single atom from one location to another one.
The destination will be overriden.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>src</strong> :  input int</p>
<p><strong>dst</strong> :  input int</p>
<p><strong>swap</strong> :  input int, optional</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">copy_entry</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.copy_from">
<code class="descname">copy_from</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.copy_from"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.copy_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace contents of this Atoms object with data from <cite>other</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.copy_properties">
<code class="descname">copy_properties</code><span class="sig-paren">(</span><em>from</em>, <em>property_list</em><span class="optional">[</span>, <em>case_sensitive</em>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.copy_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy some properties from one atoms struct to another
The destination will be overriden.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>from</strong> : <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><code class="xref py py-class docutils literal"><span class="pre">Atoms</span></code></a> object</p>
<p><strong>property_list</strong> :  input string(len=-1)</p>
<p><strong>case_sensitive</strong> :  input int, optional</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">copy_properties</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.copy_without_connect">
<code class="descname">copy_without_connect</code><span class="sig-paren">(</span><em>to</em>, <em>from</em><span class="optional">[</span>, <em>properties</em>, <em>properties_array</em>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.copy_without_connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a copy of the atoms object <code class="docutils literal"><span class="pre">from</span></code> without including
connectivity information. Useful for saving the state of a
dynamical simulation without incurring too great a memory
cost.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>to</strong> : <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><code class="xref py py-class docutils literal"><span class="pre">Atoms</span></code></a> object</p>
<p><strong>from</strong> : <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><code class="xref py py-class docutils literal"><span class="pre">Atoms</span></code></a> object</p>
<p><strong>properties</strong> :  input string(len=-1), optional</p>
<p><strong>properties_array</strong> :  input rank-2 array(&#8216;S&#8217;) with bounds (qp_n0,(*)), optional</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_copy_without_connect</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.cosine">
<code class="descname">cosine</code><span class="sig-paren">(</span><em>i</em>, <em>j</em>, <em>k</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.cosine" title="Permalink to this definition">¶</a></dt>
<dd><p>Cosine of the angle j&#8211;i&#8211;k</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>i</strong> :  input int</p>
<p><strong>j</strong> :  input int</p>
<p><strong>k</strong> :  input int</p>
<p><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_cosine</strong> :  float</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">cosine</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.cosine_neighbour">
<code class="descname">cosine_neighbour</code><span class="sig-paren">(</span><em>i</em>, <em>n</em>, <em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.cosine_neighbour" title="Permalink to this definition">¶</a></dt>
<dd><p>Cosine of the angle n&#8211;i&#8211;m where {<img class="math" src="_images/math/64b057f2648659ddd229341cecdae58d08751849.png" alt="n,m"/>} are the {:math:<a href="#id1"><span class="problematic" id="id2">`</span></a>n`th, :math:<a href="#id3"><span class="problematic" id="id4">`</span></a>m`th} neighbours of i</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>i</strong> :  input int</p>
<p><strong>n</strong> :  input int</p>
<p><strong>m</strong> :  input int</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_cosine_neighbour</strong> :  float</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">cosine_neighbour</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.density">
<code class="descname">density</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.density"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.density" title="Permalink to this definition">¶</a></dt>
<dd><p>Density in units of <img class="math" src="_images/math/846ffd8410b4e884443d8b7f2df37cc417186f4c.png" alt="g/m^3"/>. If <cite>mass</cite> property exists,
use that, otherwise we use <cite>z</cite> and ElementMass table.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.diff">
<code class="descname">diff</code><span class="sig-paren">(</span><em>i</em>, <em>j</em>, <em>shift</em><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.diff" title="Permalink to this definition">¶</a></dt>
<dd><p>Difference vector between atoms <img class="math" src="_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/> and <img class="math" src="_images/math/d32c78b759903e3f4bd4fd2ce0b86358f7500c5d.png" alt="j"/> if they are separated by a shift of <code class="docutils literal"><span class="pre">shift</span></code></p>
<div class="math">
<p><img src="_images/math/3edb8d8b8a6d26fb6ad4223b6219a27cc4cadc67.png" alt="\mathbf{u}_{ij} = \mathbf{r}_j - \mathbf{r}_i + \mathbf{R} \cdot  \mathbf{s}"/></p>
</div><p>where <img class="math" src="_images/math/ff6cfab7c0ba183019cdbbfcb00f139e8044cf95.png" alt="\mathbf{R}"/> is the <code class="docutils literal"><span class="pre">lattice</span></code> matrix and <img class="math" src="_images/math/b65434e0533eb4c0ecf4469a1d8a9fb197260cc9.png" alt="\mathbf{s}"/> the shift</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>i</strong> :  input int</p>
<p><strong>j</strong> :  input int</p>
<p><strong>shift</strong> :  input rank-1 array(&#8216;i&#8217;) with bounds (3)</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_diff</strong> :  rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">diff</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.diff_min_image">
<code class="descname">diff_min_image</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.diff_min_image" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Return the minimum image difference vector between two atoms or</dt>
<dd>positions. End points can be specified by any combination of
atoms indices &#8216;i&#8217; and &#8216;j&#8217; and absolute coordinates &#8216;u&#8217; and
&#8216;w&#8217;.</dd>
</dl>
<p>Wrapper around Fortran interface <code class="docutils literal"><span class="pre">diff_min_image</span></code> containing multiple routines:</p>
<blockquote>
<div><dl class="function">
<dt>
<code class="descname">diff_min_image</code><span class="sig-paren">(</span><em>v</em>, <em>j</em><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>v</strong> (<em>input rank-1 array(&#8216;d&#8217;) with bounds (3)</em>) &#8211; </li>
<li><strong>j</strong> (<em>input int</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_diff_vec_atom</strong> &#8211;  rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">diff_vec_atom</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">diff_min_image</code><span class="sig-paren">(</span><em>i</em>, <em>w</em><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>i</strong> (<em>input int</em>) &#8211; </li>
<li><strong>w</strong> (<em>input rank-1 array(&#8216;d&#8217;) with bounds (3)</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_diff_atom_vec</strong> &#8211;  rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">diff_atom_vec</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">diff_min_image</code><span class="sig-paren">(</span><em>i</em>, <em>j</em><span class="optional">[</span>, <em>shift</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>i</strong> (<em>input int</em>) &#8211; </li>
<li><strong>j</strong> (<em>input int</em>) &#8211; </li>
<li><strong>shift</strong> (<em>input rank-1 array(&#8216;i&#8217;) with bounds (3), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_diff_atom_atom</strong> &#8211;  rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">diff_atom_atom</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">diff_min_image</code><span class="sig-paren">(</span><em>v</em>, <em>w</em><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>v</strong> (<em>input rank-1 array(&#8216;d&#8217;) with bounds (3)</em>) &#8211; </li>
<li><strong>w</strong> (<em>input rank-1 array(&#8216;d&#8217;) with bounds (3)</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_diff_vec_vec</strong> &#8211;  rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">diff_vec_vec</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.direction_cosines">
<code class="descname">direction_cosines</code><span class="sig-paren">(</span><em>i</em>, <em>j</em>, <em>shift</em><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.direction_cosines" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two atoms <img class="math" src="_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/> and <img class="math" src="_images/math/d32c78b759903e3f4bd4fd2ce0b86358f7500c5d.png" alt="j"/> and a shift returns the direction
cosines of the differnece vector from <img class="math" src="_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/> to <img class="math" src="_images/math/d32c78b759903e3f4bd4fd2ce0b86358f7500c5d.png" alt="j"/>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>i</strong> :  input int</p>
<p><strong>j</strong> :  input int</p>
<p><strong>shift</strong> :  input rank-1 array(&#8216;i&#8217;) with bounds (3)</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_direction_cosines</strong> :  rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">direction_cosines</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.direction_cosines_min_image">
<code class="descname">direction_cosines_min_image</code><span class="sig-paren">(</span><em>i</em>, <em>j</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.direction_cosines_min_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Direction cosines of the difference vector from <img class="math" src="_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/> to <img class="math" src="_images/math/d32c78b759903e3f4bd4fd2ce0b86358f7500c5d.png" alt="j"/></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>i</strong> :  input int</p>
<p><strong>j</strong> :  input int</p>
<p><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_direction_cosines_min_image</strong> :  rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">direction_cosines_min_image</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.directionality">
<code class="descname">directionality</code><span class="sig-paren">(</span><em>origin</em>, <em>list</em><span class="optional">[</span>, <em>method</em>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.directionality" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an origin atom and a list of other atoms, give information as to whether the other atoms
are distributed roughly linearly, planar or spherically around the origin atom.</p>
<p>The most notable use is to check that the splines in adjustable potential will be able to reproduce
a randomly oriented force difference well.</p>
<p>The information returned is the set of eigenvectors and associated eigenvalues of the directionality
ellipsoid. One large e-value suggests roughly linear clustering, two similar and one small e-values suggest
a planar distribution, while three similar e-values suggests almost spherical distribution (when copies of
the atoms reflected through the origin atom are also considered).</p>
<p>To acheive a more spherical distribution, atoms along the e-vector(s) with the smallest e-value(s) should be
added to the index list (See <code class="docutils literal"><span class="pre">CosAngle_To_Line</span></code> below).</p>
<p>The matrix which is diagonalised is an average of the outer products of the unit vectors from the origin
atom to the other atoms.</p>
<p>An outer product has 1 eigenvector which is the vector it was constructed from with
eigenvalue 1 and the other eigenvectors have eigenvalue 0.</p>
<p>The eigenvalues of the averaged matrix sum to 1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>origin</strong> :  input int</p>
<blockquote>
<div><p>The origin atom</p>
</div></blockquote>
<p><strong>list</strong> : <a class="reference internal" href="table.html#quippy.table.Table" title="quippy.table.Table"><code class="xref py py-class docutils literal"><span class="pre">Table</span></code></a> object</p>
<blockquote>
<div><p>Indices and shifts of the other atoms relative to origin</p>
</div></blockquote>
<p><strong>evalues</strong> :  rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
<blockquote>
<div><p>Eigenvalues of the directionality matrix</p>
</div></blockquote>
<p><strong>evectors</strong> :  rank-2 array(&#8216;d&#8217;) with bounds (3,3)</p>
<blockquote>
<div><p>Eigenvectors of the directionality matrix</p>
</div></blockquote>
<p><strong>method</strong> :  input int, optional</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">METHOD</span> <span class="pre">=</span> <span class="pre">1</span></code> Directionality ellipsoid method.
<code class="docutils literal"><span class="pre">METHOD</span> <span class="pre">=</span> <span class="pre">2</span></code> Singular Value Decomposition method (default)</p>
</div></blockquote>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">directionality</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.distance">
<code class="descname">distance</code><span class="sig-paren">(</span><em>i</em>, <em>j</em>, <em>shift</em><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Return distance between atoms <code class="docutils literal"><span class="pre">i</span></code> and <code class="docutils literal"><span class="pre">j</span></code> if they are separated by a shift
of <code class="docutils literal"><span class="pre">shift</span></code>.</p>
<div class="math">
<p><img src="_images/math/9c6d629b14fbee517ed725d05005de4aaa342249.png" alt="r_{ij} = \left| \mathbf{r}_j - \mathbf{r}_i + \mathbf{R} \cdot  \mathbf{s} \right|"/></p>
</div><p>where <img class="math" src="_images/math/ff6cfab7c0ba183019cdbbfcb00f139e8044cf95.png" alt="\mathbf{R}"/> is the <code class="docutils literal"><span class="pre">lattice</span></code> matrix and <img class="math" src="_images/math/b65434e0533eb4c0ecf4469a1d8a9fb197260cc9.png" alt="\mathbf{s}"/> the shift.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>i</strong> :  input int</p>
<p><strong>j</strong> :  input int</p>
<p><strong>shift</strong> :  input rank-1 array(&#8216;i&#8217;) with bounds (3)</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_distance</strong> :  float</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">distance</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.distance_min_image">
<code class="descname">distance_min_image</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.distance_min_image" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>This interface calculates the distance between the nearest periodic images of two points (or atoms).</dt>
<dd>Return minimum image distance between two atoms or positions.
End points can be specified by any combination of atoms indices
&#8216;i&#8217; and &#8216;j&#8217; and absolute coordinates &#8216;u&#8217; and &#8216;w&#8217;. If &#8216;shift&#8217; is
present the periodic shift between the two atoms or points will
be returned in it.</dd>
</dl>
<p>Wrapper around Fortran interface <code class="docutils literal"><span class="pre">distance_min_image</span></code> containing multiple routines:</p>
<blockquote>
<div><dl class="function">
<dt>
<code class="descname">distance_min_image</code><span class="sig-paren">(</span><em>v</em>, <em>w</em><span class="optional">[</span>, <em>shift</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>v</strong> (<em>input rank-1 array(&#8216;d&#8217;) with bounds (3)</em>) &#8211; </li>
<li><strong>w</strong> (<em>input rank-1 array(&#8216;d&#8217;) with bounds (3)</em>) &#8211; </li>
<li><strong>shift</strong> (<em>in/output rank-1 array(&#8216;i&#8217;) with bounds (3), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_distance8_vec_vec</strong> &#8211;  float</p>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">distance8_vec_vec</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">distance_min_image</code><span class="sig-paren">(</span><em>i</em>, <em>j</em><span class="optional">[</span>, <em>shift</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>i</strong> (<em>input int</em>) &#8211; </li>
<li><strong>j</strong> (<em>input int</em>) &#8211; </li>
<li><strong>shift</strong> (<em>in/output rank-1 array(&#8216;i&#8217;) with bounds (3), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_distance8_atom_atom</strong> &#8211;  float</p>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">distance8_atom_atom</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">distance_min_image</code><span class="sig-paren">(</span><em>i</em>, <em>v</em><span class="optional">[</span>, <em>shift</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>i</strong> (<em>input int</em>) &#8211; </li>
<li><strong>v</strong> (<em>input rank-1 array(&#8216;d&#8217;) with bounds (3)</em>) &#8211; </li>
<li><strong>shift</strong> (<em>in/output rank-1 array(&#8216;i&#8217;) with bounds (3), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_distance8_atom_vec</strong> &#8211;  float</p>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">distance8_atom_vec</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">distance_min_image</code><span class="sig-paren">(</span><em>v</em>, <em>j</em><span class="optional">[</span>, <em>shift</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>v</strong> (<em>input rank-1 array(&#8216;d&#8217;) with bounds (3)</em>) &#8211; </li>
<li><strong>j</strong> (<em>input int</em>) &#8211; </li>
<li><strong>shift</strong> (<em>in/output rank-1 array(&#8216;i&#8217;) with bounds (3), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_distance8_vec_atom</strong> &#8211;  float</p>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">distance8_vec_atom</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.edit">
<code class="descname">edit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.edit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.edit" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify atoms interactively through ase-gui viewer.</p>
<p>Conflicts leading to undesirable behaviour might arise
when matplotlib has been pre-imported with certain
incompatible backends and while trying to use the
plot feature inside the interactive ag. To circumvent,
please set matplotlib.use(&#8216;gtk&#8217;) before calling this
method.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.equivalent">
<code class="descname">equivalent</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.equivalent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.equivalent" title="Permalink to this definition">¶</a></dt>
<dd><p>Test for equivalence of two Atoms objects.</p>
<p>Equivalence is less strong than equality.  Equality (written
<cite>self == other</cite>) requires all properties and parameters to be
equal. Equivalence requires only that the number of atoms,
positions, atomic numbers, unit cell and periodic boundary
conditions match.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The quippy expression a.equivalent(b) has the same
definition as a == b in ASE. This means that a quippy.Atoms
instance can be compared with an ase.Atoms instance using
this method.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.extend"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Extend atoms object by appending atoms from <em>other</em>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.fake_smooth_pos">
<code class="descname">fake_smooth_pos</code><span class="sig-paren">(</span><em>at</em>, <em>mix</em><span class="optional">[</span>, <em>persistent</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.fake_smooth_pos" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>at</strong> : <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><code class="xref py py-class docutils literal"><span class="pre">Atoms</span></code></a> object</p>
<p><strong>mix</strong> :  input float</p>
<p class="last"><strong>persistent</strong> :  input int, optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">fake_smooth_pos</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_all_distances">
<code class="descname">get_all_distances</code><span class="sig-paren">(</span><em>mic=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_all_distances"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_all_distances" title="Permalink to this definition">¶</a></dt>
<dd><p>Return distances of all of the atoms with all of the atoms.</p>
<p>Use mic=True to use the Minimum Image Convention.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_angle">
<code class="descname">get_angle</code><span class="sig-paren">(</span><em>list</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_angle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Get angle formed by three atoms.</p>
<p>calculate angle between the vectors list[1]-&gt;list[0] and
list[1]-&gt;list[2], where list contains the atomic indexes in
question.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_angular_momentum">
<code class="descname">get_angular_momentum</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_angular_momentum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_angular_momentum" title="Permalink to this definition">¶</a></dt>
<dd><p>Get total angular momentum with respect to the center of mass.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_array">
<code class="descname">get_array</code><span class="sig-paren">(</span><em>name</em>, <em>copy=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an array.</p>
<p>Returns a copy unless the optional argument copy is false.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_atom">
<code class="descname">get_atom</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.get_atom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary containing the properties of the atom with
index <cite>i</cite>. If fortran_indexing=True (the default), <cite>i</cite> should be in
range 1..self.n, otherwise it should be in range 0..(self.n-1).</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_atomic_numbers">
<code class="descname">get_atomic_numbers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_atomic_numbers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_atomic_numbers" title="Permalink to this definition">¶</a></dt>
<dd><p>Get integer array of atomic numbers.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_calculator">
<code class="descname">get_calculator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_calculator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_calculator" title="Permalink to this definition">¶</a></dt>
<dd><p>Get currently attached calculator object.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_cell">
<code class="descname">get_cell</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_cell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the three unit cell vectors as a 3x3 ndarray.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_celldisp">
<code class="descname">get_celldisp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_celldisp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_celldisp" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the unit cell displacement vectors.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_center_of_mass">
<code class="descname">get_center_of_mass</code><span class="sig-paren">(</span><em>scaled=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_center_of_mass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_center_of_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the center of mass.</p>
<p>If scaled=True the center of mass in scaled coordinates
is returned.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_charges">
<code class="descname">get_charges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_charges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_charges" title="Permalink to this definition">¶</a></dt>
<dd><p>Get calculated charges.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_chemical_formula">
<code class="descname">get_chemical_formula</code><span class="sig-paren">(</span><em>mode='hill'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_chemical_formula"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_chemical_formula" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the chemial formula as a string based on the chemical symbols.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>mode: str</dt>
<dd><p class="first">There are three different modes available:</p>
<p>&#8216;all&#8217;: The list of chemical symbols are contracted to at string,
e.g. [&#8216;C&#8217;, &#8216;H&#8217;, &#8216;H&#8217;, &#8216;H&#8217;, &#8216;O&#8217;, &#8216;H&#8217;] becomes &#8216;CHHHOH&#8217;.</p>
<p>&#8216;reduce&#8217;: The same as &#8216;all&#8217; where repeated elements are contracted
to a single symbol and a number, e.g. &#8216;CHHHOCHHH&#8217; is reduced to
&#8216;CH3OCH3&#8217;.</p>
<p class="last">&#8216;hill&#8217;: The list of chemical symbols are contracted to a string
following the Hill notation (alphabetical order with C and H
first), e.g. &#8216;CHHHOCHHH&#8217; is reduced to &#8216;C2H6O&#8217; and &#8216;SOOHOHO&#8217; to
&#8216;H2O4S&#8217;. This is default.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_chemical_symbols">
<code class="descname">get_chemical_symbols</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_chemical_symbols"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_chemical_symbols" title="Permalink to this definition">¶</a></dt>
<dd><p>Get list of chemical symbol strings.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_dihedral">
<code class="descname">get_dihedral</code><span class="sig-paren">(</span><em>list</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_dihedral"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_dihedral" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate dihedral angle.</p>
<p>Calculate dihedral angle between the vectors list[0]-&gt;list[1]
and list[2]-&gt;list[3], where list contains the atomic indexes
in question.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_dipole_moment">
<code class="descname">get_dipole_moment</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_dipole_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_dipole_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the electric dipole moment for the atoms object.</p>
<p>Only available for calculators which has a get_dipole_moment()
method.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_distance">
<code class="descname">get_distance</code><span class="sig-paren">(</span><em>a0</em>, <em>a1</em>, <em>mic=False</em>, <em>vector=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_distance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Return distance between two atoms.</p>
<p>Use mic=True to use the Minimum Image Convention.
vector=True gives the distance vector (from a0 to a1).</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_distances">
<code class="descname">get_distances</code><span class="sig-paren">(</span><em>a</em>, <em>indices</em>, <em>mic=False</em>, <em>vector=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_distances"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_distances" title="Permalink to this definition">¶</a></dt>
<dd><p>Return distances of atom No.i with a list of atoms.</p>
<p>Use mic=True to use the Minimum Image Convention.
vector=True gives the distance vector (from a to self[indices]).</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_forces">
<code class="descname">get_forces</code><span class="sig-paren">(</span><em>apply_constraint=True</em>, <em>md=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_forces"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_forces" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate atomic forces.</p>
<p>Ask the attached calculator to calculate the forces and apply
constraints.  Use <em>apply_constraint=False</em> to get the raw
forces.</p>
<p>For molecular dynamics (md=True) we don&#8217;t apply the constraint
to the forces but to the momenta.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_initial_charges">
<code class="descname">get_initial_charges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_initial_charges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_initial_charges" title="Permalink to this definition">¶</a></dt>
<dd><p>Get array of initial charges.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_initial_magnetic_moments">
<code class="descname">get_initial_magnetic_moments</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_initial_magnetic_moments"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_initial_magnetic_moments" title="Permalink to this definition">¶</a></dt>
<dd><p>Get array of initial magnetic moments.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_kinetic_energy">
<code class="descname">get_kinetic_energy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_kinetic_energy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_kinetic_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the kinetic energy.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_magnetic_moment">
<code class="descname">get_magnetic_moment</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_magnetic_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_magnetic_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Get calculated total magnetic moment.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_magnetic_moments">
<code class="descname">get_magnetic_moments</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_magnetic_moments"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_magnetic_moments" title="Permalink to this definition">¶</a></dt>
<dd><p>Get calculated local magnetic moments.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_masses">
<code class="descname">get_masses</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_masses"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_masses" title="Permalink to this definition">¶</a></dt>
<dd><p>Get array of masses.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_momenta">
<code class="descname">get_momenta</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_momenta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_momenta" title="Permalink to this definition">¶</a></dt>
<dd><p>Get array of momenta.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_moments_of_inertia">
<code class="descname">get_moments_of_inertia</code><span class="sig-paren">(</span><em>vectors=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_moments_of_inertia"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_moments_of_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the moments of inertia along the principal axes.</p>
<p>The three principal moments of inertia are computed from the
eigenvalues of the symmetric inertial tensor. Periodic boundary
conditions are ignored. Units of the moments of inertia are
amu*angstrom**2.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_number_of_atoms">
<code class="descname">get_number_of_atoms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_number_of_atoms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_number_of_atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of atoms.</p>
<p>Equivalent to len(atoms) in the standard ASE Atoms class.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_param_value">
<code class="descname">get_param_value</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.get_param_value" title="Permalink to this definition">¶</a></dt>
<dd><p>get a (per-configuration) value from the atoms%params dictionary</p>
<p>Wrapper around Fortran interface <code class="docutils literal"><span class="pre">get_param_value</span></code> containing multiple routines:</p>
<blockquote>
<div><dl class="function">
<dt>
<code class="descname">get_param_value</code><span class="sig-paren">(</span><em>key</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>key</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>value</strong> &#8211;  float</p>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_get_param_value_real</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">get_param_value</code><span class="sig-paren">(</span><em>key</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>key</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>value</strong> &#8211;  string(len=10240)</p>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_get_param_value_str</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">get_param_value</code><span class="sig-paren">(</span><em>key</em>, <em>n0</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>key</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>n0</strong> (<em>input int</em>) &#8211; shape(qp_value,0)</li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>value</strong> &#8211;  rank-1 array(&#8216;d&#8217;) with bounds (qp_n0)</p>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_get_param_value_real_a</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">get_param_value</code><span class="sig-paren">(</span><em>key</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>key</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>value</strong> &#8211;  int</p>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_get_param_value_int</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">get_param_value</code><span class="sig-paren">(</span><em>key</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>key</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>value</strong> &#8211;  int</p>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_get_param_value_logical</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">get_param_value</code><span class="sig-paren">(</span><em>key</em>, <em>n0</em>, <em>n1</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>key</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>n0</strong> (<em>input int</em>) &#8211; shape(qp_value,0)</li>
<li><strong>n1</strong> (<em>input int</em>) &#8211; shape(qp_value,1)</li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>value</strong> &#8211;  rank-2 array(&#8216;d&#8217;) with bounds (qp_n0,qp_n1)</p>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_get_param_value_real_a2</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">get_param_value</code><span class="sig-paren">(</span><em>key</em>, <em>value</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>key</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>value</strong> (<code class="xref py py-class docutils literal"><span class="pre">Extendable_str</span></code> object) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_get_param_value_es</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">get_param_value</code><span class="sig-paren">(</span><em>key</em>, <em>n0</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>key</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>n0</strong> (<em>input int</em>) &#8211; shape(qp_value,0)</li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>value</strong> &#8211;  rank-1 array(&#8216;i&#8217;) with bounds (qp_n0)</p>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_get_param_value_int_a</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_pbc">
<code class="descname">get_pbc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_pbc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_pbc" title="Permalink to this definition">¶</a></dt>
<dd><p>Get periodic boundary condition flags.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_positions">
<code class="descname">get_positions</code><span class="sig-paren">(</span><em>wrap=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_positions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Get array of positions. If wrap==True, wraps atoms back
into unit cell.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_potential_energies">
<code class="descname">get_potential_energies</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_potential_energies"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_potential_energies" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the potential energies of all the atoms.</p>
<p>Only available with calculators supporting per-atom energies
(e.g. classical potentials).</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_potential_energy">
<code class="descname">get_potential_energy</code><span class="sig-paren">(</span><em>force_consistent=False</em>, <em>apply_constraint=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_potential_energy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_potential_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate potential energy.</p>
<p>Ask the attached calculator to calculate the potential energy and
apply constraints.  Use <em>apply_constraint=False</em> to get the raw
forces.</p>
<p>When supported by the calculator, either the energy extrapolated
to zero Kelvin or the energy consistent with the forces (the free
energy) can be returned.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_reciprocal_cell">
<code class="descname">get_reciprocal_cell</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_reciprocal_cell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_reciprocal_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the three reciprocal lattice vectors as a 3x3 ndarray.</p>
<p>Note that the commonly used factor of 2 pi for Fourier
transforms is not included here.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_scaled_positions">
<code class="descname">get_scaled_positions</code><span class="sig-paren">(</span><em>wrap=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_scaled_positions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_scaled_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Get positions relative to unit cell.</p>
<p>If wrap is True, atoms outside the unit cell will be wrapped into
the cell in those directions with periodic boundary conditions
so that the scaled coordinates are between zero and one.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_stress">
<code class="descname">get_stress</code><span class="sig-paren">(</span><em>voigt=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_stress"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_stress" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate stress tensor.</p>
<p>Returns an array of the six independent components of the
symmetric stress tensor, in the traditional Voigt order
(xx, yy, zz, yz, xz, xy) or as a 3x3 matrix.  Default is Voigt
order.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_stresses">
<code class="descname">get_stresses</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_stresses"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_stresses" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the stress-tensor of all the atoms.</p>
<p>Only available with calculators supporting per-atom energies and
stresses (e.g. classical potentials).  Even for such calculators
there is a certain arbitrariness in defining per-atom stresses.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_tags">
<code class="descname">get_tags</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_tags"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>Get integer array of tags.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_temperature">
<code class="descname">get_temperature</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_temperature"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_temperature" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the temperature in Kelvin.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_total_energy">
<code class="descname">get_total_energy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_total_energy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_total_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the total energy - potential plus kinetic energy.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_velocities">
<code class="descname">get_velocities</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_velocities"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_velocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Get array of velocities.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_volume">
<code class="descname">get_volume</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.get_volume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Get volume of unit cell.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.has">
<code class="descname">has</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.has"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.has" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for existence of array.</p>
<p>name must be one of: &#8216;tags&#8217;, &#8216;momenta&#8217;, &#8216;masses&#8217;, &#8216;magmoms&#8217;,
&#8216;charges&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.has_property">
<code class="descname">has_property</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.has_property" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function to test if a property is present. No checking
of property type is done. Property names are case-insensitive.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> :  input string(len=-1)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>ret_atoms_has_property</strong> :  int</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">has_property</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.index_to_z_index">
<code class="descname">index_to_z_index</code><span class="sig-paren">(</span><em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.index_to_z_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from a single index in range 1..this.N to a CASTEP-style (element, index) pair</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>index</strong> :  input int</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>ret_z_index</strong> :  int</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">index_to_z_index</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.is_domain_decomposed">
<code class="descname">is_domain_decomposed</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.is_domain_decomposed" title="Permalink to this definition">¶</a></dt>
<dd><p>atoms_is_domain_decomposed</p>
<p>Is this atoms object domain decomposed?</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>ret_</strong> :  int</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">is_domain_decomposed</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.is_initialised">
<code class="descname">is_initialised</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.is_initialised" title="Permalink to this definition">¶</a></dt>
<dd><p>Is this atoms object initialised?</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>ret_</strong> :  int</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">is_initialised</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.is_min_image">
<code class="descname">is_min_image</code><span class="sig-paren">(</span><em>i</em><span class="optional">[</span>, <em>alt_connect</em>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.is_min_image" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>i</strong> :  input int</p>
<p><strong>alt_connect</strong> : <a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> object, optional</p>
<p><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_is_min_image</strong> :  int</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">is_min_image</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.is_nearest_neighbour">
<code class="descname">is_nearest_neighbour</code><span class="sig-paren">(</span><em>i</em>, <em>n</em><span class="optional">[</span>, <em>alt_connect</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.is_nearest_neighbour" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if an atom&#8217;s :math:<a href="#id5"><span class="problematic" id="id6">`</span></a>n`th neighbour is one if its nearest neighbours</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>i</strong> :  input int</p>
<p><strong>n</strong> :  input int</p>
<p><strong>alt_connect</strong> : <a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> object, optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_is_nearest_neighbour</strong> :  int</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">is_nearest_neighbour</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.is_nearest_neighbour_abs_index">
<code class="descname">is_nearest_neighbour_abs_index</code><span class="sig-paren">(</span><em>i</em>, <em>j</em><span class="optional">[</span>, <em>alt_connect</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.is_nearest_neighbour_abs_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if an atom <code class="docutils literal"><span class="pre">j</span></code> is one of <a href="#id7"><span class="problematic" id="id8">``</span></a>i``s nearest neighbours</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>i</strong> :  input int</p>
<p><strong>j</strong> :  input int</p>
<p><strong>alt_connect</strong> : <a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> object, optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_is_nearest_neighbour_abs_index</strong> :  int</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">is_nearest_neighbour_abs_index</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.iteratoms">
<code class="descname">iteratoms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.iteratoms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.iteratoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over atoms, calling get_atom() for each one</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.kinetic_energy">
<code class="descname">kinetic_energy</code><span class="sig-paren">(</span><span class="optional">[</span><em>mpi_obj</em>, <em>local_ke</em>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.kinetic_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total kinetic energy <img class="math" src="_images/math/e74031185d07cfd0bd1566be386399a316a9e624.png" alt="E_k = \sum_{i} \frac{1}{2} m v^2"/></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mpi_obj</strong> : <a class="reference internal" href="mpi_context.html#quippy.mpi_context.MPI_context" title="quippy.mpi_context.MPI_context"><code class="xref py py-class docutils literal"><span class="pre">MPI_context</span></code></a> object, optional</p>
<p><strong>local_ke</strong> :  input int, optional</p>
<p><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_ke</strong> :  float</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_kinetic_energy</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/DynamicalSystem.f95">src/libAtoms/DynamicalSystem.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.kinetic_virial">
<code class="descname">kinetic_virial</code><span class="sig-paren">(</span><span class="optional">[</span><em>mpi_obj</em>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.kinetic_virial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total kinetic virial <img class="math" src="_images/math/f394c2f44d750bbad26ca9b3257ec68688ac24d6.png" alt="w_ij = \sum_{k} \frac{1}{2} m v_i v_j"/></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mpi_obj</strong> : <a class="reference internal" href="mpi_context.html#quippy.mpi_context.MPI_context" title="quippy.mpi_context.MPI_context"><code class="xref py py-class docutils literal"><span class="pre">MPI_context</span></code></a> object, optional</p>
<p><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_kv</strong> :  rank-2 array(&#8216;d&#8217;) with bounds (3,3)</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_kinetic_virial</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/DynamicalSystem.f95">src/libAtoms/DynamicalSystem.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.list_matching_prop">
<code class="descname">list_matching_prop</code><span class="sig-paren">(</span><em>at</em>, <em>list</em>, <em>name</em>, <em>value</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.list_matching_prop" title="Permalink to this definition">¶</a></dt>
<dd><p>Find atoms which have integer property <code class="docutils literal"><span class="pre">prop</span></code> with value <code class="docutils literal"><span class="pre">value</span></code>
and return them in a table <code class="docutils literal"><span class="pre">list</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>at</strong> : <code class="xref py py-class docutils literal"><span class="pre">atoms</span></code> object</p>
<p><strong>list</strong> : <a class="reference internal" href="table.html#quippy.table.Table" title="quippy.table.Table"><code class="xref py py-class docutils literal"><span class="pre">Table</span></code></a> object</p>
<p><strong>name</strong> :  input string(len=-1)</p>
<p><strong>value</strong> :  input int</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">list_matching_prop</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.make_convex">
<code class="descname">make_convex</code><span class="sig-paren">(</span><em>list</em><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.make_convex" title="Permalink to this definition">¶</a></dt>
<dd><p>Add atoms to <code class="docutils literal"><span class="pre">list</span></code> to make the selection region convex, i.e. if <img class="math" src="_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/> and
<img class="math" src="_images/math/d32c78b759903e3f4bd4fd2ce0b86358f7500c5d.png" alt="j"/> are nearest neighbours, with <img class="math" src="_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/> in the list and not <img class="math" src="_images/math/d32c78b759903e3f4bd4fd2ce0b86358f7500c5d.png" alt="j"/> then <img class="math" src="_images/math/d32c78b759903e3f4bd4fd2ce0b86358f7500c5d.png" alt="j"/> will be added
if more than half its nearest neighbours are in the list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> : <a class="reference internal" href="table.html#quippy.table.Table" title="quippy.table.Table"><code class="xref py py-class docutils literal"><span class="pre">Table</span></code></a> object</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">make_convex</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/clusters.f95">src/libAtoms/clusters.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.map_into_cell">
<code class="descname">map_into_cell</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.map_into_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>atoms_map_into_cell</p>
<dl class="docutils">
<dt>Map atomic positions into the unit cell so that lattice</dt>
<dd>coordinates satisfy <img class="math" src="_images/math/a0718313c2bc1fb125299359718cd9569655679b.png" alt="-0.5 \le t_x,t_y,t_z &lt; 0.5"/></dd>
</dl>
<p>Map atomic fractional positions back into the unit cell
<img class="math" src="_images/math/a0718313c2bc1fb125299359718cd9569655679b.png" alt="-0.5 \le t_x,t_y,t_z &lt; 0.5"/></p>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">map_into_cell</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.mark_cylinder">
<code class="descname">mark_cylinder</code><span class="sig-paren">(</span><em>p</em>, <em>v</em>, <em>r</em><span class="optional">[</span>, <em>periodic</em>, <em>mark_name</em>, <em>mark_value</em>, <em>intersection</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.mark_cylinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark atoms in a cylinder centred on the point <cite>p</cite> with axis <cite>v</cite> and radius <cite>r</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>p</strong> :  input rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
<p><strong>v</strong> :  input rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
<p><strong>r</strong> :  input float</p>
<p><strong>periodic</strong> :  input int, optional</p>
<p><strong>mark_name</strong> :  input string(len=-1), optional</p>
<p><strong>mark_value</strong> :  input int, optional</p>
<p class="last"><strong>intersection</strong> :  input int, optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">mark_cylinder</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/frametools.f95">src/libAtoms/frametools.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.mark_sphere">
<code class="descname">mark_sphere</code><span class="sig-paren">(</span><em>p</em>, <em>r</em><span class="optional">[</span>, <em>periodic</em>, <em>mark_name</em>, <em>mark_value</em>, <em>intersection</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.mark_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark atoms in a cylinder centred on the point <cite>p</cite> with radius <cite>r</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>p</strong> :  input rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
<p><strong>r</strong> :  input float</p>
<p><strong>periodic</strong> :  input int, optional</p>
<p><strong>mark_name</strong> :  input string(len=-1), optional</p>
<p><strong>mark_value</strong> :  input int, optional</p>
<p class="last"><strong>intersection</strong> :  input int, optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">mark_sphere</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/frametools.f95">src/libAtoms/frametools.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.md5_hash">
<code class="descname">md5_hash</code><span class="sig-paren">(</span><em>ndigits</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.md5_hash"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.md5_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Hash an atoms object with a precision of ndigits decimal
digits.  Atomic numbers, lattice and fractional positions are
fed to MD5 to form the hash.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.mem_estimate">
<code class="descname">mem_estimate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.mem_estimate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.mem_estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate memory usage of this Atoms object, in bytes</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.moment_of_inertia_tensor">
<code class="descname">moment_of_inertia_tensor</code><span class="sig-paren">(</span><span class="optional">[</span><em>origin</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.moment_of_inertia_tensor" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>origin</strong> :  input rank-1 array(&#8216;d&#8217;) with bounds (3), optional</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>ret_moi</strong> :  rank-2 array(&#8216;d&#8217;) with bounds (3,3)</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">moment_of_inertia_tensor</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/DynamicalSystem.f95">src/libAtoms/DynamicalSystem.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.momentum">
<code class="descname">momentum</code><span class="sig-paren">(</span><span class="optional">[</span><em>indices</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.momentum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total momentum <img class="math" src="_images/math/f65d5abc743368c153c92e6f5062a4127a165b1c.png" alt="\mathbf{p} = \sum_i \mathbf{m_i} \mathbf{v_i}"/>.
Optionally only include the contribution of a subset of atoms.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>indices</strong> :  input rank-1 array(&#8216;i&#8217;) with bounds (qp_n0), optional</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>ret_p</strong> :  rank-1 array(&#8216;d&#8217;) with bounds (3)</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_momentum</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/DynamicalSystem.f95">src/libAtoms/DynamicalSystem.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.n_neighbours">
<code class="descname">n_neighbours</code><span class="sig-paren">(</span><em>i</em><span class="optional">[</span>, <em>max_dist</em>, <em>max_factor</em>, <em>alt_connect</em>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.n_neighbours" title="Permalink to this definition">¶</a></dt>
<dd><p>Neighbour list stuff
Return the number of neighbour that atom <code class="docutils literal"><span class="pre">i</span></code> has.  If the
optional arguments max_dist or max_factor are present then only
neighbours closer than this cutoff are included.  <code class="docutils literal"><span class="pre">alt_connect</span></code>
can be set to another Connection object to use alternative
connectivity information, for example <code class="docutils literal"><span class="pre">hysteretic_connect</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>i</strong> :  input int</p>
<p><strong>max_dist</strong> :  input float, optional</p>
<p><strong>max_factor</strong> :  input float, optional</p>
<p><strong>alt_connect</strong> : <a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> object, optional</p>
<p><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_n</strong> :  int</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">n_neighbours</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.neighbour">
<code class="descname">neighbour</code><span class="sig-paren">(</span><em>i</em>, <em>n</em><span class="optional">[</span>, <em>distance</em>, <em>diff</em>, <em>cosines</em>, <em>shift</em>, <em>index</em>, <em>max_dist</em>, <em>jn</em>, <em>alt_connect</em>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.neighbour" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the <img class="math" src="_images/math/564e1690873cb931ec03c3bf1ebb71b1be229940.png" alt="n^{\mbox{\small{th}}}"/> neighbour of atom <img class="math" src="_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/>. Together with the
previous function, this facilites a loop over the neighbours of atom <img class="math" src="_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/>. Optionally, we
return other geometric information, such as distance, direction cosines and difference vector,
and also a direct index into the neighbour tables. If <img class="math" src="_images/math/d01dfa7e20a8a81ee22143f4b480a9c35120c063.png" alt="i &lt;= j"/>, this is an index into <code class="docutils literal"><span class="pre">neighbour1(i)</span></code>;
if <img class="math" src="_images/math/a044f4112fbdd1acdc9c2b99d39fdd137cd90c17.png" alt="i &gt; j"/>, it is an index into <code class="docutils literal"><span class="pre">neighbour1(j)</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre>do n = 1,atoms_n_neighbours(at, i)
   j = atoms_neighbour(at, i, n, distance, diff, cosines, shift, index)

   ...
end do
</pre></div>
</div>
<p>If distance <img class="math" src="_images/math/78ebd4cdaabc38007623a06192e4af8b92432fc5.png" alt="&gt;"/> max_dist, return 0, and do not waste time calculating other quantities.
<code class="docutils literal"><span class="pre">alt_connect</span></code> has the same meaning as <code class="docutils literal"><span class="pre">n_neighbours</span></code>.</p>
<p>Here&#8217;s a typical loop construct in Python. Note how <cite>r</cite> and <cite>u</cite>
are created before the loop: arguments which are both optional
and <code class="docutils literal"><span class="pre">intent(out)</span></code> in Fortran are converted to <code class="docutils literal"><span class="pre">intent(in,out)</span></code> for quippy. ::</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">r</span> <span class="o">=</span> <span class="n">farray</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">fzeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">frange</span><span class="p">(</span><span class="n">at</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">frange</span><span class="p">(</span><span class="n">at</span><span class="o">.</span><span class="n">n_neighbours</span><span class="p">(</span><span class="n">i</span><span class="p">)):</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">at</span><span class="o">.</span><span class="n">neighbour</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="n">r</span><span class="p">,</span> <span class="n">diff</span><span class="o">=</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>i</strong> :  input int</p>
<p><strong>n</strong> :  input int</p>
<p><strong>distance</strong> :  in/output rank-0 array(float,&#8217;d&#8217;), optional</p>
<p><strong>diff</strong> :  in/output rank-1 array(&#8216;d&#8217;) with bounds (3), optional</p>
<p><strong>cosines</strong> :  in/output rank-1 array(&#8216;d&#8217;) with bounds (3), optional</p>
<p><strong>shift</strong> :  in/output rank-1 array(&#8216;i&#8217;) with bounds (3), optional</p>
<p><strong>index</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
<p><strong>max_dist</strong> :  input float, optional</p>
<p><strong>jn</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
<p><strong>alt_connect</strong> : <a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> object, optional</p>
<p><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_j</strong> :  int</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">neighbour</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>i=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.pop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove and return atom at index <em>i</em> (default last).</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.print_">
<code class="descname">print_</code><span class="sig-paren">(</span><span class="optional">[</span><em>file</em>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.print_" title="Permalink to this definition">¶</a></dt>
<dd><p>Print a verbose textual description of an Atoms object to the default logger or to
a specificied Inoutput object.
Print a verbose textual description of a Connection object to the default
logger or to a specificied Inoutput object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>file</strong> : <a class="reference internal" href="system.html#quippy.system.InOutput" title="quippy.system.InOutput"><code class="xref py py-class docutils literal"><span class="pre">InOutput</span></code></a> object, optional</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">print_</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.print_atom">
<code class="descname">print_atom</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.print_atom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.print_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Pretty-print the properties of the atom with index <cite>i</cite></p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.prop_names_string">
<code class="descname">prop_names_string</code><span class="sig-paren">(</span><span class="optional">[</span><em>with_types</em>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.prop_names_string" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>with_types</strong> :  input int, optional</p>
<p><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_prop_names_string</strong> :  string(len=10240)</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">prop_names_string</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.rattle">
<code class="descname">rattle</code><span class="sig-paren">(</span><em>stdev=0.001</em>, <em>seed=42</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.rattle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.rattle" title="Permalink to this definition">¶</a></dt>
<dd><p>Randomly displace atoms.</p>
<p>This method adds random displacements to the atomic positions,
taking a possible constraint into account.  The random numbers are
drawn from a normal distribution of standard deviation stdev.</p>
<p>For a parallel calculation, it is important to use the same
seed on all processors!</p>
</dd></dl>

<dl class="classmethod">
<dt id="quippy.atoms.Atoms.read">
<em class="property">classmethod </em><code class="descname">read</code><span class="sig-paren">(</span><em>source</em>, <em>format=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.read"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Class method to read Atoms object from file <cite>source</cite> according to <cite>format</cite></p>
<p>If <cite>format</cite> is None, filetype is inferred from filename.
Returns a new Atoms instance; to read into an existing Atoms
object, use the read_from() method.</p>
<p>If <cite>source</cite> corresponds to a known format then it used
to construct an appropriate iterator from the <code class="xref py py-attr docutils literal"><span class="pre">AtomsReaders</span></code>
dictionary. See <a class="reference internal" href="io.html#fileformats"><span>Supported File Formats</span></a> for a list of supported
file formats.</p>
<p>If <cite>source</cite> corresponds to an unknown format then it is
expected to be an iterator returning <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><code class="xref py py-class docutils literal"><span class="pre">Atoms</span></code></a> objects.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.read_cinoutput">
<code class="descname">read_cinoutput</code><span class="sig-paren">(</span><em>cio</em><span class="optional">[</span>, <em>properties</em>, <em>properties_array</em>, <em>frame</em>, <em>zero</em>, <em>range</em>, <em>str</em>, <em>estr</em>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.read_cinoutput" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>cio</strong> : <code class="xref py py-class docutils literal"><span class="pre">CInOutput</span></code> object</p>
<p><strong>properties</strong> :  input string(len=-1), optional</p>
<p><strong>properties_array</strong> :  input rank-2 array(&#8216;S&#8217;) with bounds (qp_n0,(*)), optional</p>
<p><strong>frame</strong> :  input int, optional</p>
<p><strong>zero</strong> :  input int, optional</p>
<p><strong>range</strong> :  input rank-1 array(&#8216;i&#8217;) with bounds (2), optional</p>
<p><strong>str</strong> :  input string(len=-1), optional</p>
<p><strong>estr</strong> : <code class="xref py py-class docutils literal"><span class="pre">Extendable_str</span></code> object, optional</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_read_cinoutput</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/CInOutput.f95">src/libAtoms/CInOutput.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.read_from">
<code class="descname">read_from</code><span class="sig-paren">(</span><em>source</em>, <em>**readargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.read_from"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.read_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace contents of this Atoms object with Atoms read from <cite>source</cite></p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.realpos">
<code class="descname">realpos</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.realpos" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the real position of atom <code class="docutils literal"><span class="pre">i</span></code>, taking into account the
stored travel across the periodic boundary conditions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>i</strong> :  input int</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>ret_realpos</strong> :  rank-1 array(&#8216;d&#8217;) with bounds (3)</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">realpos</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.remove_atoms">
<code class="descname">remove_atoms</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.remove_atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove one or more atoms from an Atoms object.</p>
<p>Wrapper around Fortran interface <code class="docutils literal"><span class="pre">remove_atoms</span></code> containing multiple routines:</p>
<blockquote>
<div><dl class="function">
<dt>
<code class="descname">remove_atoms</code><span class="sig-paren">(</span><em>mask</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mask</strong> (<em>input rank-1 array(&#8216;i&#8217;) with bounds (qp_n0)</em>) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">remove_atom_multiple_mask</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">remove_atoms</code><span class="sig-paren">(</span><em>i</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>i</strong> (<em>input int</em>) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">remove_atom_single</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">remove_atoms</code><span class="sig-paren">(</span><em>atom_indices</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>atom_indices</strong> (<em>input rank-1 array(&#8216;i&#8217;) with bounds (qp_n0)</em>) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">remove_atom_multiple</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.remove_property">
<code class="descname">remove_property</code><span class="sig-paren">(</span><em>name</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.remove_property" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a property from this atoms object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>name</strong> :  input string(len=-1)</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">remove_property</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.repeat">
<code class="descname">repeat</code><span class="sig-paren">(</span><em>rep</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.repeat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Create new repeated atoms object.</p>
<p>The <em>rep</em> argument should be a sequence of three positive
integers like <em>(2,3,1)</em> or a single integer (<em>r</em>) equivalent
to <em>(r,r,r)</em>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.repoint">
<code class="descname">repoint</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.repoint" title="Permalink to this definition">¶</a></dt>
<dd><p>OMIT</p>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_repoint</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>axis</em>, <em>angle</em><span class="optional">[</span>, <em>rank1</em>, <em>rank2</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate this Atoms object, transforming all rank 1 and rank 2 tensors parameters and properties</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>axis</strong> :  input rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
<p><strong>angle</strong> :  input float</p>
<p><strong>rank1</strong> :  input string(len=-1), optional</p>
<p class="last"><strong>rank2</strong> :  input string(len=-1), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">rotate</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.rotate_dihedral">
<code class="descname">rotate_dihedral</code><span class="sig-paren">(</span><em>list</em>, <em>angle</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.rotate_dihedral"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.rotate_dihedral" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate dihedral angle.</p>
<p>Complementing the two routines above: rotate a group by a
predefined dihedral angle, starting from its current
configuration</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.rotate_euler">
<code class="descname">rotate_euler</code><span class="sig-paren">(</span><em>center=(0</em>, <em>0</em>, <em>0)</em>, <em>phi=0.0</em>, <em>theta=0.0</em>, <em>psi=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.rotate_euler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.rotate_euler" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate atoms via Euler angles.</p>
<p>See e.g <a class="reference external" href="http://mathworld.wolfram.com/EulerAngles.html">http://mathworld.wolfram.com/EulerAngles.html</a> for explanation.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>center :</dt>
<dd>The point to rotate about. A sequence of length 3 with the
coordinates, or &#8216;COM&#8217; to select the center of mass, &#8216;COP&#8217; to
select center of positions or &#8216;COU&#8217; to select center of cell.</dd>
<dt>phi :</dt>
<dd>The 1st rotation angle around the z axis.</dd>
<dt>theta :</dt>
<dd>Rotation around the x axis.</dd>
<dt>psi :</dt>
<dd>2nd rotation around the z axis.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.select">
<code class="descname">select</code><span class="sig-paren">(</span><em>mask=None</em>, <em>list=None</em>, <em>orig_index=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.select"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.select" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><code class="xref py py-class docutils literal"><span class="pre">Atoms</span></code></a> containing a subset of the atoms in this Atoms object</p>
<p>One of either <cite>mask</cite> or <cite>list</cite> should be present.  If <cite>mask</cite>
is given it should be a rank one array of length <cite>self.n</cite>. In
this case atoms corresponding to true values in <cite>mask</cite> will be
included in the result.  If <cite>list</cite> is present it should be an
arry of list containing atom indices to include in the result.</p>
<p>If <cite>orig_index</cite> is True (default), the new object will contain
an <code class="docutils literal"><span class="pre">orig_index</span></code> property mapping the indices of the new atoms
back to the original larger Atoms object.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_angle">
<code class="descname">set_angle</code><span class="sig-paren">(</span><em>list</em>, <em>angle</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.set_angle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.set_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Set angle formed by three atoms.</p>
<p>Sets the angle between vectors list[1]-&gt;list[0] and
list[1]-&gt;list[2].</p>
<p>Same usage as in set_dihedral.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_array">
<code class="descname">set_array</code><span class="sig-paren">(</span><em>name</em>, <em>a</em>, <em>dtype=None</em>, <em>shape=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.set_array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.set_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Update array.</p>
<p>If <em>shape</em> is not <em>None</em>, the shape of <em>a</em> will be checked.
If <em>a</em> is <em>None</em>, then the array is deleted.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_atomic_numbers">
<code class="descname">set_atomic_numbers</code><span class="sig-paren">(</span><em>numbers</em>, <em>set_species=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.set_atomic_numbers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.set_atomic_numbers" title="Permalink to this definition">¶</a></dt>
<dd><p>Set atomic numbers and optionally also species property (default True)</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_atoms">
<code class="descname">set_atoms</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.set_atoms" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Set atomic numbers (in the &#8216;z&#8217; integer property), species names</dt>
<dd>(in &#8216;species&#8217; string property) and optionally masses (if &#8216;mass&#8217;
property exists in the Atoms object).</dd>
</dl>
<p>Wrapper around Fortran interface <code class="docutils literal"><span class="pre">set_atoms</span></code> containing multiple routines:</p>
<blockquote>
<div><dl class="function">
<dt>
<code class="descname">set_atoms</code><span class="sig-paren">(</span><em>z</em><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>z</strong> (<em>input int</em>) &#8211; </td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_set_atoms_singlez</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">set_atoms</code><span class="sig-paren">(</span><em>z</em><span class="optional">[</span>, <em>mass</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Set atomic numbers and optionally masses (if mass property is present)
If <code class="docutils literal"><span class="pre">mass</span></code> is not specified then <code class="docutils literal"><span class="pre">ElementMass(Z)</span></code> is used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>z</strong> (<em>input rank-1 array(&#8216;i&#8217;) with bounds (qp_n0)</em>) &#8211; </li>
<li><strong>mass</strong> (<em>input rank-1 array(&#8216;d&#8217;) with bounds (qp_n1), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_set_atoms</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_calculator">
<code class="descname">set_calculator</code><span class="sig-paren">(</span><em>calc=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.set_calculator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.set_calculator" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach calculator object.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_cell">
<code class="descname">set_cell</code><span class="sig-paren">(</span><em>cell</em>, <em>scale_atoms=False</em>, <em>fix=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.set_cell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.set_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Set unit cell vectors.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>cell :</dt>
<dd>Unit cell.  A 3x3 matrix (the three unit cell vectors) or
just three numbers for an orthorhombic cell.</dd>
<dt>scale_atoms <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Fix atomic positions or move atoms with the unit cell?
Default behavior is to <em>not</em> move the atoms (scale_atoms=False).</dd>
</dl>
<p>Examples:</p>
<p>Two equivalent ways to define an orthorhombic cell:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">set_cell</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">set_cell</span><span class="p">([(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">)])</span>
</pre></div>
</div>
<p>FCC unit cell:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">set_cell</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_celldisp">
<code class="descname">set_celldisp</code><span class="sig-paren">(</span><em>celldisp</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.set_celldisp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.set_celldisp" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the unit cell displacement vectors.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_chemical_symbols">
<code class="descname">set_chemical_symbols</code><span class="sig-paren">(</span><em>symbols</em>, <em>set_species=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.set_chemical_symbols"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.set_chemical_symbols" title="Permalink to this definition">¶</a></dt>
<dd><p>Set chemical symbols - sets Z and optionally also species properties (default True)</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_comm_property">
<code class="descname">set_comm_property</code><span class="sig-paren">(</span><em>propname</em><span class="optional">[</span>, <em>comm_atoms</em>, <em>comm_ghosts</em>, <em>comm_reverse</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.set_comm_property" title="Permalink to this definition">¶</a></dt>
<dd><p>Set which properties to communicate when
comm_atoms:   Communicate when atom is moved to different domain.</p>
<blockquote>
<div>Forces, for example, may be excluded since they are updated
on every time step.</div></blockquote>
<dl class="docutils">
<dt>comm_ghosts:  Communicate when atom is dublicated as a ghost on a domain.</dt>
<dd>Masses, for example, might be excluded since atoms are
propagated on the domain they reside in only.</dd>
<dt>comm_reverse: Communicate back from ghost atoms to the original domain atom</dt>
<dd>and accumulate</dd>
</dl>
<p>By default, properties are not communicated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>propname</strong> :  input string(len=-1)</p>
<p><strong>comm_atoms</strong> :  input int, optional</p>
<p><strong>comm_ghosts</strong> :  input int, optional</p>
<p class="last"><strong>comm_reverse</strong> :  input int, optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">set_comm_property</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_constraint">
<code class="descname">set_constraint</code><span class="sig-paren">(</span><em>constraint=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.set_constraint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.set_constraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply one or more constrains.</p>
<p>The <em>constraint</em> argument must be one constraint object or a
list of constraint objects.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_cutoff">
<code class="descname">set_cutoff</code><span class="sig-paren">(</span><em>cutoff</em><span class="optional">[</span>, <em>cutoff_skin</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.set_cutoff" title="Permalink to this definition">¶</a></dt>
<dd><p>set a uniform cutoff
Specify a uniform neighbour cutoff throughout the system.
Optionally set <code class="docutils literal"><span class="pre">cutoff_skin</span></code> at the same time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>cutoff</strong> :  input float</p>
<p class="last"><strong>cutoff_skin</strong> :  input float, optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">set_cutoff</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_cutoff_minimum">
<code class="descname">set_cutoff_minimum</code><span class="sig-paren">(</span><em>cutoff</em><span class="optional">[</span>, <em>cutoff_skin</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.set_cutoff_minimum" title="Permalink to this definition">¶</a></dt>
<dd><p>increase cutoff
Set the cutoff to at least the requested value
Optionally set <code class="docutils literal"><span class="pre">cutoff_skin</span></code> at the same time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>cutoff</strong> :  input float</p>
<p class="last"><strong>cutoff_skin</strong> :  input float, optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">set_cutoff_minimum</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_dihedral">
<code class="descname">set_dihedral</code><span class="sig-paren">(</span><em>list</em>, <em>angle</em>, <em>mask=None</em>, <em>indices=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.set_dihedral"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.set_dihedral" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the dihedral angle between vectors list[0]-&gt;list[1] and
list[2]-&gt;list[3] by changing the atom indexed by list[3]
if mask is not None, all the atoms described in mask
(read: the entire subgroup) are moved. Alternatively to the mask,
the indices of the atoms to be rotated can be supplied.</p>
<p>example: the following defines a very crude
ethane-like molecule and twists one half of it by 30 degrees.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span><span class="s">&#39;HHCCHH&#39;</span><span class="p">,</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="go">                             [1, 0, 0], [2, 1, 0], [2, -1, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span><span class="o">.</span><span class="n">set_dihedral</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="mi">7</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span><span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_distance">
<code class="descname">set_distance</code><span class="sig-paren">(</span><em>a0</em>, <em>a1</em>, <em>distance</em>, <em>fix=0.5</em>, <em>mic=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.set_distance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.set_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the distance between two atoms.</p>
<p>Set the distance between atoms <em>a0</em> and <em>a1</em> to <em>distance</em>.
By default, the center of the two atoms will be fixed.  Use
<em>fix=0</em> to fix the first atom, <em>fix=1</em> to fix the second
atom and <em>fix=0.5</em> (default) to fix the center of the bond.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_initial_charges">
<code class="descname">set_initial_charges</code><span class="sig-paren">(</span><em>charges=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.set_initial_charges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.set_initial_charges" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the initial charges.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_initial_magnetic_moments">
<code class="descname">set_initial_magnetic_moments</code><span class="sig-paren">(</span><em>magmoms=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.set_initial_magnetic_moments"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.set_initial_magnetic_moments" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the initial magnetic moments.</p>
<p>Use either one or three numbers for every atom (collinear
or non-collinear spins).</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_lattice">
<code class="descname">set_lattice</code><span class="sig-paren">(</span><em>lattice</em>, <em>scale_positions=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.set_lattice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.set_lattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the lattice vectors, keeping the inverse lattice vectors
up to date. Optionally map the existing atoms into the new cell
and recalculate connectivity (by default scale_positions=False).</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_map_shift">
<code class="descname">set_map_shift</code><span class="sig-paren">(</span><span class="optional">[</span><em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.set_map_shift" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">set_map_shift</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_masses">
<code class="descname">set_masses</code><span class="sig-paren">(</span><em>masses='defaults'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.set_masses"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.set_masses" title="Permalink to this definition">¶</a></dt>
<dd><p>Set atomic masses.</p>
<p>The array masses should contain a list of masses.  In case
the masses argument is not given or for those elements of the
masses list that are None, standard values are set.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_momenta">
<code class="descname">set_momenta</code><span class="sig-paren">(</span><em>momenta</em>, <em>apply_constraint=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.set_momenta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.set_momenta" title="Permalink to this definition">¶</a></dt>
<dd><p>Set momenta.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_param_value">
<code class="descname">set_param_value</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.set_param_value" title="Permalink to this definition">¶</a></dt>
<dd><p>set a (per-configuration) value from the atoms%params dictionary</p>
<p>Wrapper around Fortran interface <code class="docutils literal"><span class="pre">set_param_value</span></code> containing multiple routines:</p>
<blockquote>
<div><dl class="function">
<dt>
<code class="descname">set_param_value</code><span class="sig-paren">(</span><em>key</em>, <em>value</em><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>key</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>value</strong> (<em>input rank-1 array(&#8216;i&#8217;) with bounds (qp_n0)</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_set_param_value_int_a</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">set_param_value</code><span class="sig-paren">(</span><em>key</em>, <em>value</em><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>key</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>value</strong> (<em>input rank-2 array(&#8216;d&#8217;) with bounds (qp_n0,qp_n1)</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_set_param_value_real_a2</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">set_param_value</code><span class="sig-paren">(</span><em>key</em>, <em>value</em><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>key</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>value</strong> (<em>input int</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_set_param_value_int</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">set_param_value</code><span class="sig-paren">(</span><em>key</em>, <em>value</em><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>key</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>value</strong> (<em>input string(len=-1)</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_set_param_value_str</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">set_param_value</code><span class="sig-paren">(</span><em>key</em>, <em>value</em><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>key</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>value</strong> (<em>input rank-1 array(&#8216;d&#8217;) with bounds (qp_n0)</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_set_param_value_real_a</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">set_param_value</code><span class="sig-paren">(</span><em>key</em>, <em>value</em><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>key</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>value</strong> (<em>input float</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_set_param_value_real</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">set_param_value</code><span class="sig-paren">(</span><em>key</em>, <em>value</em><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>key</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>value</strong> (<em>input int</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_set_param_value_logical</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_pbc">
<code class="descname">set_pbc</code><span class="sig-paren">(</span><em>pbc</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.set_pbc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.set_pbc" title="Permalink to this definition">¶</a></dt>
<dd><p>Set periodic boundary condition flags.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_positions">
<code class="descname">set_positions</code><span class="sig-paren">(</span><em>newpositions</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.set_positions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.set_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Set positions, honoring any constraints.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_scaled_positions">
<code class="descname">set_scaled_positions</code><span class="sig-paren">(</span><em>scaled</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.set_scaled_positions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.set_scaled_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Set positions relative to unit cell.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_tags">
<code class="descname">set_tags</code><span class="sig-paren">(</span><em>tags</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.set_tags"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.set_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>Set tags for all atoms. If only one tag is supplied, it is
applied to all atoms.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_velocities">
<code class="descname">set_velocities</code><span class="sig-paren">(</span><em>velocities</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.set_velocities"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.set_velocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the momenta by specifying the velocities.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_zs">
<code class="descname">set_zs</code><span class="sig-paren">(</span><span class="optional">[</span><em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.set_zs" title="Permalink to this definition">¶</a></dt>
<dd><p>set Zs from species</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">set_zs</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.shuffle">
<code class="descname">shuffle</code><span class="sig-paren">(</span><em>new_indices</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.shuffle" title="Permalink to this definition">¶</a></dt>
<dd><p>Reshuffle the order of the atomic indices to new_indices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>new_indices</strong> :  input rank-1 array(&#8216;i&#8217;) with bounds (qp_n0)</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">shuffle</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.sort">
<code class="descname">sort</code><span class="sig-paren">(</span><em>sort_index</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>sort atoms according to an externally provided field</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sort_index</strong> :  input rank-1 array(&#8216;d&#8217;) with bounds (qp_n0)</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">sort_by_rindex</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.sort_by_rindex">
<code class="descname">sort_by_rindex</code><span class="sig-paren">(</span><em>sort_index</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.sort_by_rindex" title="Permalink to this definition">¶</a></dt>
<dd><p>sort atoms according to an externally provided field</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sort_index</strong> :  input rank-1 array(&#8216;d&#8217;) with bounds (qp_n0)</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_sort_by_rindex</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.transform_basis">
<code class="descname">transform_basis</code><span class="sig-paren">(</span><em>l</em><span class="optional">[</span>, <em>rank1</em>, <em>rank2</em>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.transform_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Basis transformation of rank 0, 1 and 2 tensors real values in Atoms object.
This routine transforms rank 1 and rank 2 tensors in this.params and
this.properties. Tensors are identified by having the correct type
(real arrays) and shape (i.e. 3, (3, 3), (3, this.N) (9, this.N) for
vector paramters, tensor parameters, vector properties and tensor
properties respectively), and by having a name which is included in
the relevant list. Extra names can be added to the lists with the
rank1 and rank2 arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>l</strong> :  input rank-2 array(&#8216;d&#8217;) with bounds (3,3)</p>
<p><strong>rank1</strong> :  input string(len=-1), optional</p>
<p><strong>rank2</strong> :  input string(len=-1), optional</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">transform_basis</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.translate">
<code class="descname">translate</code><span class="sig-paren">(</span><em>displacement</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.translate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate atomic positions.</p>
<p>The displacement argument can be a float an xyz vector or an
nx3 array (where n is the number of atoms).</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.undo_com_motion">
<code class="descname">undo_com_motion</code><span class="sig-paren">(</span><em>at</em><span class="optional">[</span>, <em>persistent</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.undo_com_motion" title="Permalink to this definition">¶</a></dt>
<dd><p>undo center of mass motion, with or without persistent atoms object
without persistent atoms object, global storage is used, and calling on multiple trajcetories
interspersed will not work</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>at</strong> : <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><code class="xref py py-class docutils literal"><span class="pre">Atoms</span></code></a> object</p>
<p class="last"><strong>persistent</strong> :  input int, optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">undo_com_motion</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.undo_pbc_jumps">
<code class="descname">undo_pbc_jumps</code><span class="sig-paren">(</span><em>at</em><span class="optional">[</span>, <em>persistent</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.undo_pbc_jumps" title="Permalink to this definition">¶</a></dt>
<dd><p>undo pbc jumps, assuming nearest periodic image, with or without persistent atoms object
without persistent atoms object, global storage is used, and calling on multiple trajcetories
interspersed will not work</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>at</strong> : <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><code class="xref py py-class docutils literal"><span class="pre">Atoms</span></code></a> object</p>
<p class="last"><strong>persistent</strong> :  input int, optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">undo_pbc_jumps</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.unskew_cell">
<code class="descname">unskew_cell</code><span class="sig-paren">(</span><span class="optional">[</span><em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.unskew_cell" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Unskew lattice so the cosines of the lattice angles fall between</dt>
<dd><img class="math" src="_images/math/e38b5464730f744c74c919e3496d5dd484ad892d.png" alt="-0.5"/> and <img class="math" src="_images/math/a55a85777307c1a74cfb7bf8d4d833d9bbb50046.png" alt="0.5"/></dd>
</dl>
<p>Unskew lattice so the cosines of the lattice angles fall between
<img class="math" src="_images/math/e38b5464730f744c74c919e3496d5dd484ad892d.png" alt="-0.5"/> and <img class="math" src="_images/math/a55a85777307c1a74cfb7bf8d4d833d9bbb50046.png" alt="0.5"/></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">unskew_cell</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.wrap">
<code class="descname">wrap</code><span class="sig-paren">(</span><em>center=(0.5</em>, <em>0.5</em>, <em>0.5)</em>, <em>pbc=None</em>, <em>eps=1e-07</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ase/atoms.html#Atoms.wrap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.wrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrap positions to unit cell.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>center: three float</dt>
<dd>The positons in fractional coordinates that the new positions
will be nearest possible to.</dd>
<dt>pbc: one or 3 bool</dt>
<dd>For each axis in the unit cell decides whether the positions
will be moved along this axis.  By default, the boundary
conditions of the Atoms object will be used.</dd>
<dt>eps: float</dt>
<dd>Small number to prevent slightly negative coordinates from beeing
wrapped.</dd>
</dl>
<p>See also the <a class="reference external" href="https://wiki.fysik.dtu.dk/ase/ase/utils.html#ase.utils.geometry.wrap_positions" title="(in ASE v)"><code class="xref py py-func docutils literal"><span class="pre">ase.utils.geometry.wrap_positions()</span></code></a> function.
Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span><span class="s">&#39;H&#39;</span><span class="p">,</span>
<span class="gp">... </span>          <span class="p">[[</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.01</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">]],</span>
<span class="gp">... </span>          <span class="n">cell</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span>
<span class="gp">... </span>          <span class="n">pbc</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">wrap</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">positions</span>
<span class="go">array([[ 0.9 ,  0.01, -0.5 ]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>dest=None</em>, <em>format=None</em>, <em>properties=None</em>, <em>prefix=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write this <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><code class="xref py py-class docutils literal"><span class="pre">Atoms</span></code></a> object to <cite>dest</cite>. If <cite>format</cite> is
absent it is inferred from the file extension or type of <cite>dest</cite>,
as described for the <a class="reference internal" href="#quippy.atoms.Atoms.read" title="quippy.atoms.Atoms.read"><code class="xref py py-meth docutils literal"><span class="pre">read()</span></code></a> method.  If <cite>properties</cite> is
present, it should be a list of property names to include in the
output file, e.g. <cite>[&#8216;species&#8217;, &#8216;pos&#8217;]</cite>.</p>
<p>See <a class="reference internal" href="io.html#fileformats"><span>Supported File Formats</span></a> for a list of supported file formats.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.write_cinoutput">
<code class="descname">write_cinoutput</code><span class="sig-paren">(</span><em>cio</em><span class="optional">[</span>, <em>properties</em>, <em>properties_array</em>, <em>prefix</em>, <em>int_format</em>, <em>real_format</em>, <em>frame</em>, <em>shuffle</em>, <em>deflate</em>, <em>deflate_level</em>, <em>estr</em>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.write_cinoutput" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>cio</strong> : <code class="xref py py-class docutils literal"><span class="pre">CInOutput</span></code> object</p>
<p><strong>properties</strong> :  input string(len=-1), optional</p>
<p><strong>properties_array</strong> :  input rank-2 array(&#8216;S&#8217;) with bounds (qp_n0,(*)), optional</p>
<p><strong>prefix</strong> :  input string(len=-1), optional</p>
<p><strong>int_format</strong> :  input string(len=-1), optional</p>
<p><strong>real_format</strong> :  input string(len=-1), optional</p>
<p><strong>frame</strong> :  input int, optional</p>
<p><strong>shuffle</strong> :  input int, optional</p>
<p><strong>deflate</strong> :  input int, optional</p>
<p><strong>deflate_level</strong> :  input int, optional</p>
<p><strong>estr</strong> : <code class="xref py py-class docutils literal"><span class="pre">Extendable_str</span></code> object, optional</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">atoms_write_cinoutput</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/CInOutput.f95">src/libAtoms/CInOutput.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.z_index_to_index">
<code class="descname">z_index_to_index</code><span class="sig-paren">(</span><em>z</em>, <em>z_index</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.z_index_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse of atoms_index_to_z_index</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>z</strong> :  input int</p>
<p><strong>z_index</strong> :  input int</p>
<p><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_index</strong> :  int</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">z_index_to_index</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.zero">
<code class="descname">zero</code><span class="sig-paren">(</span><span class="optional">[</span><em>indices</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero data in an Atoms structure &#8212;
this doesn``t finalise it or change it``s size. We zero <code class="docutils literal"><span class="pre">this.pos</span></code>,
<code class="docutils literal"><span class="pre">this.Z</span></code> and <code class="docutils literal"><span class="pre">this.species</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>indices</strong> :  input int, optional</p>
<blockquote class="last">
<div><p>Optionally only zero the specified indices.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">zero</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.zero_angular_momentum">
<code class="descname">zero_angular_momentum</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.Atoms.zero_angular_momentum" title="Permalink to this definition">¶</a></dt>
<dd><p>give the system a rigid body rotation so as to zero the angular momentum about the centre of mass</p>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">zero_angular_momentum</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/DynamicalSystem.f95">src/libAtoms/DynamicalSystem.f95</a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.arrays">
<code class="descname">arrays</code><a class="headerlink" href="#quippy.atoms.Atoms.arrays" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides access to ASE arrays, stored in QUIP properties dict</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.calc">
<code class="descname">calc</code><a class="headerlink" href="#quippy.atoms.Atoms.calc" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculator object.</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.cell">
<code class="descname">cell</code><a class="headerlink" href="#quippy.atoms.Atoms.cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Attribute for direct manipulation of the unit cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.connect">
<code class="descname">connect</code><a class="headerlink" href="#quippy.atoms.Atoms.connect" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> object</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.constraints">
<code class="descname">constraints</code><a class="headerlink" href="#quippy.atoms.Atoms.constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Constraints of the atoms.</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.cutoff">
<code class="descname">cutoff</code><a class="headerlink" href="#quippy.atoms.Atoms.cutoff" title="Permalink to this definition">¶</a></dt>
<dd><p>Cutoff distance for neighbour calculations. Default -1.0 (unset).</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.cutoff_skin">
<code class="descname">cutoff_skin</code><a class="headerlink" href="#quippy.atoms.Atoms.cutoff_skin" title="Permalink to this definition">¶</a></dt>
<dd><p>If set, increase cutoff by this amount to reduce calc_connect() frequency</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.domain">
<code class="descname">domain</code><a class="headerlink" href="#quippy.atoms.Atoms.domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Domain decomposition object</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.fixed_size">
<code class="descname">fixed_size</code><a class="headerlink" href="#quippy.atoms.Atoms.fixed_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Can the number of atoms be changed after initialisation?</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.g">
<code class="descname">g</code><a class="headerlink" href="#quippy.atoms.Atoms.g" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse lattice (stored for speed)</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.hysteretic_connect">
<code class="descname">hysteretic_connect</code><a class="headerlink" href="#quippy.atoms.Atoms.hysteretic_connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Hysteretic <a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> object</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.indices">
<code class="descname">indices</code><a class="headerlink" href="#quippy.atoms.Atoms.indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return array of atoms indices</p>
<p>If global <code class="docutils literal"><span class="pre">fortran_indexing</span></code> is True, returns FortranArray containing
numbers 1..self.n.  Otherwise, returns a standard numpuy array
containing numbers in range 0..(self.n-1).</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.info">
<code class="descname">info</code><a class="headerlink" href="#quippy.atoms.Atoms.info" title="Permalink to this definition">¶</a></dt>
<dd><p>ASE info dictionary</p>
<p>Entries are actually stored in QUIP params dictionary.</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.lattice">
<code class="descname">lattice</code><a class="headerlink" href="#quippy.atoms.Atoms.lattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Lattice vectors, as columns:</p>
<div class="math">
<p><img src="_images/math/d8804413e527b5dcda4e679352770e6c2776cbbc.png" alt="\left(
\begin{array}{ccc}
| &amp; | &amp; | \\ \mathbf{a} &amp; \mathbf{b} &amp; \mathbf{c} \\ | &amp; | &amp; | \\ \end{array}
\right)
= \left(
\begin{array}{ccc}
R_{11} &amp; R_{12} &amp; R_{13} \\ R_{21} &amp; R_{22} &amp; R_{23} \\  R_{31} &amp; R_{32} &amp; R_{33} \\ \end{array}
\right)"/></p>
</div><p>i.e. <img class="math" src="_images/math/a7ca8d225c064dae6b3c328bf7acd82b7d8933c9.png" alt="\mathbf{a}"/> = <code class="docutils literal"><span class="pre">lattice(:,1)</span></code>, <img class="math" src="_images/math/dd6a0c79ee7e76c8e6f1310a5d171d5b3848b685.png" alt="\mathbf{b}"/> = <code class="docutils literal"><span class="pre">lattice(:,2)</span></code> and
<img class="math" src="_images/math/c20b076757f2c84dbfba8d79beeb264442324609.png" alt="\mathbf{c}"/> <code class="docutils literal"><span class="pre">lattice(:,3)</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.n">
<code class="descname">n</code><a class="headerlink" href="#quippy.atoms.Atoms.n" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of atoms held (including ghost particles)</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.nbuffer">
<code class="descname">nbuffer</code><a class="headerlink" href="#quippy.atoms.Atoms.nbuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of atoms that can be stored in the buffers of this Atoms object</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.ndomain">
<code class="descname">ndomain</code><a class="headerlink" href="#quippy.atoms.Atoms.ndomain" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of atoms held by the local process (excluding ghost particles)</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.nneightol">
<code class="descname">nneightol</code><a class="headerlink" href="#quippy.atoms.Atoms.nneightol" title="Permalink to this definition">¶</a></dt>
<dd><p>Count as nearest neighbour if sum of covalent radii
times <code class="docutils literal"><span class="pre">this.nneightol</span></code> greater than distance between atoms.
Used in cluster carving.</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.numbers">
<code class="descname">numbers</code><a class="headerlink" href="#quippy.atoms.Atoms.numbers" title="Permalink to this definition">¶</a></dt>
<dd><p>Attribute for direct manipulation of the atomic numbers.</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.own_this">
<code class="descname">own_this</code><a class="headerlink" href="#quippy.atoms.Atoms.own_this" title="Permalink to this definition">¶</a></dt>
<dd><p>Do I own myself?</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.params">
<code class="descname">params</code><a class="headerlink" href="#quippy.atoms.Atoms.params" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="dictionary.html#quippy.dictionary.Dictionary" title="quippy.dictionary.Dictionary"><code class="xref py py-class docutils literal"><span class="pre">Dictionary</span></code></a> of parameters. Useful for storing data about this
Atoms object, for example the temperature, total energy or
applied strain. The data stored here is automatically saved to
and loaded from XYZ and NetCDF files.</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.pbc">
<code class="descname">pbc</code><a class="headerlink" href="#quippy.atoms.Atoms.pbc" title="Permalink to this definition">¶</a></dt>
<dd><p>Attribute for direct manipulation of the periodic boundary condition flags.</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.positions">
<code class="descname">positions</code><a class="headerlink" href="#quippy.atoms.Atoms.positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Attribute for direct manipulation of the positions.</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.properties">
<code class="descname">properties</code><a class="headerlink" href="#quippy.atoms.Atoms.properties" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="dictionary.html#quippy.dictionary.Dictionary" title="quippy.dictionary.Dictionary"><code class="xref py py-class docutils literal"><span class="pre">Dictionary</span></code></a> of atomic properties. A property is an array
of shape (<cite>m</cite>,`n`) where <cite>n</cite> is the number of atoms and <cite>m</cite> is
either one (for scalar properties) or three (vector
properties). Properties can be integer, real, string or logical.
String properties have a fixed length of <code class="docutils literal"><span class="pre">TABLE_STRING_LENGTH=10</span></code>
characters.</p>
<p>From Fortran, the following default properties are aliased with
arrays within the Atoms type:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">Z</span></code> - Atomic numbers, dimension is actually <img class="math" src="_images/math/9b1fafb017a070f395b466fbb58f8b2fd1f1dc1d.png" alt="(N)"/></li>
<li><code class="docutils literal"><span class="pre">species</span></code> Names of elements</li>
<li><code class="docutils literal"><span class="pre">move_mask</span></code> Atoms with <code class="docutils literal"><span class="pre">move_mask</span></code> set to zero are fixed</li>
<li><code class="docutils literal"><span class="pre">damp_mask</span></code> Damping is only applied to those atoms with <code class="docutils literal"><span class="pre">damp_mask</span></code> set to 1. By default this is set to 1 for all atoms.</li>
<li><code class="docutils literal"><span class="pre">thermostat_region</span></code> Which thermostat is applied to each atoms. By default this is set to 1 for all atoms.</li>
<li><code class="docutils literal"><span class="pre">travel</span></code> Travel across periodic conditions. <img class="math" src="_images/math/596ef05b70bc49dac4a7748d96a29fb48139dd73.png" alt="(3,N)"/> integer array. See meth:<cite>map_into_cell</cite> below.</li>
<li><code class="docutils literal"><span class="pre">pos</span></code> <img class="math" src="_images/math/596ef05b70bc49dac4a7748d96a29fb48139dd73.png" alt="(3,N)"/> array of atomic positions, in <img class="math" src="_images/math/61f08a33ffebe94e1e06451ec1142eb65ea18d35.png" alt="\mathrm{\AA}"/>. Position of atom <img class="math" src="_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/> is <code class="docutils literal"><span class="pre">pos(:,i)</span></code></li>
<li><code class="docutils literal"><span class="pre">mass</span></code> Atomic masses, dimension is <img class="math" src="_images/math/9b1fafb017a070f395b466fbb58f8b2fd1f1dc1d.png" alt="(N)"/></li>
<li><code class="docutils literal"><span class="pre">velo</span></code> <img class="math" src="_images/math/596ef05b70bc49dac4a7748d96a29fb48139dd73.png" alt="(3,N)"/> array  of atomic velocities, in <img class="math" src="_images/math/13ecb00172f72fdd977673188080c4f714253f69.png" alt="\mathrm{AA}"/>/fs.</li>
<li><code class="docutils literal"><span class="pre">acc</span></code> <img class="math" src="_images/math/596ef05b70bc49dac4a7748d96a29fb48139dd73.png" alt="(3,N)"/> array  of accelerations in <img class="math" src="_images/math/13ecb00172f72fdd977673188080c4f714253f69.png" alt="\mathrm{AA}"/>/fs:math:<cite>^2</cite></li>
<li><code class="docutils literal"><span class="pre">avgpos</span></code> <img class="math" src="_images/math/596ef05b70bc49dac4a7748d96a29fb48139dd73.png" alt="(3,N)"/> array  of time-averaged atomic positions.</li>
<li><code class="docutils literal"><span class="pre">oldpos</span></code> <img class="math" src="_images/math/596ef05b70bc49dac4a7748d96a29fb48139dd73.png" alt="(3,N)"/> array  of positions of atoms at previous time step.</li>
<li><code class="docutils literal"><span class="pre">avg_ke</span></code> Time-averaged atomic kinetic energy</li>
</ul>
</div></blockquote>
<p>Custom properties are most conveniently accessed by assign a pointer to
them with the <code class="xref py py-meth docutils literal"><span class="pre">assign_pointer()</span></code> routines.</p>
<p>From Python, each property is automatically visible as a
array attribute of the <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><code class="xref py py-class docutils literal"><span class="pre">Atoms</span></code></a> object,
for example the atomic positions are stored in a real vector
property called <cite>pos</cite>, and can be accessed as <code class="docutils literal"><span class="pre">at.pos</span></code>.</p>
<p>Properties can be added with the <a class="reference internal" href="#quippy.atoms.Atoms.add_property" title="quippy.atoms.Atoms.add_property"><code class="xref py py-meth docutils literal"><span class="pre">add_property()</span></code></a> method and
removed with <a class="reference internal" href="#quippy.atoms.Atoms.remove_property" title="quippy.atoms.Atoms.remove_property"><code class="xref py py-meth docutils literal"><span class="pre">remove_property()</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.ref_count">
<code class="descname">ref_count</code><a class="headerlink" href="#quippy.atoms.Atoms.ref_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Reference counter</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="quippy.atoms.make_lattice">
<code class="descclassname">quippy.atoms.</code><code class="descname">make_lattice</code><span class="sig-paren">(</span><em>a</em><span class="optional">[</span>, <em>b</em>, <em>c</em>, <em>alpha</em>, <em>beta</em>, <em>gamma</em>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.make_lattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a matrix of lattice vectors from the lengths <code class="docutils literal"><span class="pre">a</span></code>,``b``,``c``
and the angles <code class="docutils literal"><span class="pre">alpha</span></code>, <code class="docutils literal"><span class="pre">beta</span></code> and <code class="docutils literal"><span class="pre">gamma</span></code>.
One length must be supplied. Any missing angle is assumed to be 90 degrees
and any missing length is assumed to be <code class="docutils literal"><span class="pre">a</span></code>.
The vectors are created in a right-handed order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> :  input float</p>
<p><strong>b</strong> :  input float, optional</p>
<p><strong>c</strong> :  input float, optional</p>
<p><strong>alpha</strong> :  input float, optional</p>
<p><strong>beta</strong> :  input float, optional</p>
<p><strong>gamma</strong> :  input float, optional</p>
<p><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_lattice</strong> :  rank-2 array(&#8216;d&#8217;) with bounds (3,3)</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">make_lattice</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt id="quippy.atoms.get_lattice_params">
<code class="descclassname">quippy.atoms.</code><code class="descname">get_lattice_params</code><span class="sig-paren">(</span><em>lattice</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quippy/atoms.html#get_lattice_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.get_lattice_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper around Fortran <code class="xref py py-func docutils literal"><span class="pre">get_lattice_params_()</span></code></p>
<p>Returns parameters of <cite>lattice</cite> as 6-tuple (a,b,c,alpha,beta,gamma).</p>
</dd></dl>

<dl class="function">
<dt id="quippy.atoms.bond_length">
<code class="descclassname">quippy.atoms.</code><code class="descname">bond_length</code><span class="sig-paren">(</span><em>z1</em>, <em>z2</em><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.bond_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sum of the covalent radii of two atoms</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>z1</strong> :  input int</p>
<p><strong>z2</strong> :  input int</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_bond_length</strong> :  float</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">bond_length</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt id="quippy.atoms.termination_bond_rescale">
<code class="descclassname">quippy.atoms.</code><code class="descname">termination_bond_rescale</code><span class="sig-paren">(</span><em>z1</em>, <em>z2</em><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.termination_bond_rescale" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the rescale ratio of a Z1&#8211;H bond
generate from a Z1&#8211;Z2 bond.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>z1</strong> :  input int</p>
<p><strong>z2</strong> :  input int</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_termination_bond_rescale</strong> :  float</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">termination_bond_rescale</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt id="quippy.atoms.cell_volume">
<code class="descclassname">quippy.atoms.</code><code class="descname">cell_volume</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.cell_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate volume of unit cell</p>
<p>Routine is wrapper around Fortran interface <code class="docutils literal"><span class="pre">cell_volume</span></code> containing multiple routines:</p>
<blockquote>
<div><dl class="function">
<dt>
<code class="descclassname">quippy.atoms.</code><code class="descname">cell_volume</code><span class="sig-paren">(</span><em>lattice</em><span class="sig-paren">)</span></dt>
<dd><p>Returns the (unsigned) volume of the simulation cell of lattice</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>lattice</strong> (<em>input rank-2 array(&#8216;d&#8217;) with bounds (3,3)</em>) &#8211; </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>ret_lattice_cell_volume</strong> &#8211;  float</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">lattice_cell_volume</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="quippy.atoms.map_into_cell">
<code class="descclassname">quippy.atoms.</code><code class="descname">map_into_cell</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.map_into_cell" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Map atomic positions into the unit cell so that lattice</dt>
<dd>coordinates satisfy $-0.5 le t_x,t_y,t_z &lt; 0.5$</dd>
</dl>
<p>Routine is wrapper around Fortran interface <code class="docutils literal"><span class="pre">map_into_cell</span></code> containing multiple routines:</p>
<blockquote>
<div><dl class="function">
<dt>
<code class="descclassname">quippy.atoms.</code><code class="descname">map_into_cell</code><span class="sig-paren">(</span><em>pos</em>, <em>lattice</em>, <em>g</em><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pos</strong> (<em>in/output rank-2 array(&#8216;d&#8217;) with bounds (qp_n0,qp_n1)</em>) &#8211; </li>
<li><strong>lattice</strong> (<em>input rank-2 array(&#8216;d&#8217;) with bounds (3,3)</em>) &#8211; </li>
<li><strong>g</strong> (<em>input rank-2 array(&#8216;d&#8217;) with bounds (3,3)</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">array_map_into_cell</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">quippy.atoms.</code><code class="descname">map_into_cell</code><span class="sig-paren">(</span><em>pos</em>, <em>lattice</em>, <em>g</em><span class="optional">[</span>, <em>shift</em>, <em>mapped</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pos</strong> (<em>in/output rank-1 array(&#8216;d&#8217;) with bounds (3)</em>) &#8211; </li>
<li><strong>lattice</strong> (<em>input rank-2 array(&#8216;d&#8217;) with bounds (3,3)</em>) &#8211; </li>
<li><strong>g</strong> (<em>input rank-2 array(&#8216;d&#8217;) with bounds (3,3)</em>) &#8211; </li>
<li><strong>shift</strong> (<em>in/output rank-1 array(&#8216;i&#8217;) with bounds (3), optional</em>) &#8211; </li>
<li><strong>mapped</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">vec_map_into_cell</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="quippy.atoms.parse_atom_mask">
<code class="descclassname">quippy.atoms.</code><code class="descname">parse_atom_mask</code><span class="sig-paren">(</span><em>mask_in</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#quippy.atoms.parse_atom_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses an atom_mask, which is string consisting of the <code class="docutils literal"><span class="pre">&#64;</span></code> symbol followed by a comma separated
list of indices or ranges into a table containing all the indices it represents.
E.g. <code class="docutils literal"><span class="pre">&#64;1,37-39,54,99-102</span></code> is expanded to a table with 1, 37, 38, 39, 54, 99, 100,
101, 102 as its first integer column. There must be no spaces in the mask.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mask_in</strong> :  input string(len=-1)</p>
<p><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>atom_indices</strong> : <a class="reference internal" href="table.html#quippy.table.Table" title="quippy.table.Table"><code class="xref py py-class docutils literal"><span class="pre">Table</span></code></a> object</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <code class="docutils literal"><span class="pre">parse_atom_mask</span></code> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Atoms_types.f95">src/libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="quippy.html" title="Quippy library reference"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">quippy b9f75c6+ documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="quippy.html" >Quippy library reference</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2008-2015, James Kermode.
      Last updated on Jan 22, 2016.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>